<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Linux 指北 - pmnmq</title><meta name=Description content><meta property="og:title" content="Linux 指北"><meta property="og:description" content="Linux 常识 也许这篇文章对你没有任何作用，因为它更多的是我这4年来将 Linux 作为我日常系统之一的一些杂谈，如果你系统学过 Linux 运维，那么这篇文章对你应该是没"><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/posts/linux%E6%8C%87%E5%8C%97/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-15T10:40:33+00:00"><meta property="article:modified_time" content="2024-07-15T10:40:33+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux 指北"><meta name=twitter:description content="Linux 常识 也许这篇文章对你没有任何作用，因为它更多的是我这4年来将 Linux 作为我日常系统之一的一些杂谈，如果你系统学过 Linux 运维，那么这篇文章对你应该是没"><meta name=application-name content="pmnmq"><meta name=apple-mobile-web-app-title content="pmnmq"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://example.org/posts/linux%E6%8C%87%E5%8C%97/><link rel=prev href=http://example.org/posts/rust_axum/><link rel=next href=http://example.org/posts/fn_fnmut_fnonce/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Linux 指北","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/example.org\/posts\/linux%E6%8C%87%E5%8C%97\/"},"genre":"posts","keywords":"Linux","wordcount":10040,"url":"http:\/\/example.org\/posts\/linux%E6%8C%87%E5%8C%97\/","datePublished":"2024-07-15T10:40:33+00:00","dateModified":"2024-07-15T10:40:33+00:00","publisher":{"@type":"Organization","name":"普吉春"},"author":{"@type":"Person","name":"普吉春"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":""==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:""==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=pmnmq><img class="lazyload logo" src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=pmnmq><img class="lazyload logo" src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Linux 指北</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=http://pujichun.ink title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>普吉春</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/linux/><i class="far fa-folder fa-fw"></i>Linux</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2024-07-15>2024-07-15</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 10040 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 21 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#路径与被小看的命令>路径与被小看的命令</a><ul><li><a href=#home>$HOME</a></li><li><a href=#pwd>pwd</a></li><li><a href=#ls>ls</a></li><li><a href=#mkdir>mkdir</a></li><li><a href=#cd>cd</a></li><li><a href=#du--sh>du -sh</a></li></ul></li><li><a href=#linux-权限>Linux 权限</a><ul><li><a href=#权限>权限</a></li><li><a href=#修改文件权限>修改文件权限</a></li><li><a href=#可执行权限>可执行权限</a></li></ul></li><li><a href=#环境变量>环境变量</a><ul><li><a href=#环境变量加载>环境变量加载</a></li><li><a href=#path-变量>$PATH 变量</a></li><li><a href=#定义变量>定义变量</a></li></ul></li><li><a href=#工程师运维>工程师运维</a><ul><li><a href=#程序运行权限>程序运行权限</a></li><li><a href=#grep>grep</a></li><li><a href=#ps命令>ps命令</a></li><li><a href=#top>top</a></li><li><a href=#定时任务>定时任务</a></li><li><a href=#归档日志筛选>归档日志筛选</a></li><li><a href=#进程查杀>进程查杀</a></li><li><a href=#lsof>lsof</a></li><li><a href=#default-editor>default editor</a></li></ul></li><li><a href=#keybind-和-alias>keybind 和 alias</a><ul><li><a href=#keybind>keybind</a></li><li><a href=#alias>alias</a></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=linux-常识>Linux 常识</h1><blockquote><p>也许这篇文章对你没有任何作用，因为它更多的是我这4年来将 Linux 作为我日常系统之一的一些杂谈，如果你系统学过 Linux 运维，那么这篇文章对你应该是没有任何帮助</p></blockquote><p>在 Linux 如果遇到参数忘记的命令可以使用 <code>--help</code> 这个 flag 帮助我们，如果 help 这个 flag 没有用，可以使用 man，大多数古老的命令工具可能不支持 help，但是一定支持 man</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>man lsof
</span></span></code></pre></td></tr></table></div></div><h2 id=路径与被小看的命令>路径与被小看的命令</h2><blockquote><p>在 Linux 命令行中，路径是个奇怪的东西，很多人容易在这里迷路，对于新手它的难度堪比退出 vim</p></blockquote><p>在 Windows 上的图形化界面中路径清晰可见，好像从学电脑开始就是那么自然一样，这好比你会 PHP，然后喊出来那句 “PHP 是世界上最好的语言”，不管是因为只学过 PHP，还是发自内心，别人看你的目光都会变得异样。</p><p>在 Linux 系统中我们可以将文件系统想象成一棵树，这棵树的根节点也就是 <code>根</code> 路径用 <code>/</code> 这个表示。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/filesys.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/filesys.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/filesys.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/filesys.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/filesys.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/filesys.png></p><h3 id=home>$HOME</h3><p>当我们创建好用户之后，Linux 通常也为我们准备好了一个 <code>$HOME</code>，我们也通常成为家目录，它位于 <code>根</code> 路径下的 <code>home</code> 路径下的 <code>{username}</code> 这个文件夹中，<code>{username}</code> 是非 root 用户的用户名，如果我的用户名是 <code>jichun_pu</code> 那么这个家目录就是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/home/jichun_pu
</span></span></code></pre></td></tr></table></div></div><h3 id=pwd>pwd</h3><p>当我们登录到 Linux 中时，打开终端（SSH 连接默认在终端中），默认路径就是在 <code>$HOME</code> 路径下，我们可以通过 <code>pwd</code> 命令查看到当前所在路径</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>pwd</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>如果经常找不到自己当前的 shell 位于哪个路径下，记得使用 pwd 命令</p></blockquote><p><code>$HOME</code> 路径下的资源（文件）可以任由你随意操作，就像是在你自己家中一样非常的自由，你就是家里的山大王</p><h3 id=ls>ls</h3><p>通过 <code>ls -a</code> 命令，你可以看到你拥有的文件和文件夹，当然可能运行这个命令后可能只有几个点</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ls -a
</span></span></code></pre></td></tr></table></div></div><ul><li><strong>ls</strong>: 会列出当前的文件和文件夹</li><li><strong>ls -a</strong>: 会列出当前的文件和文件夹，包括隐藏的</li><li><strong>ls -l</strong>: 以列表的形式列出是文件还是目录，它的大小、修改日期和时间、文件或目录的名字以及文件的属主和它的权限</li><li><strong>ls -lh</strong>: 在 <code>ls -l</code> 的基础上以更容易读的方式显示出文件大小</li><li><strong>ls -F</strong>: 在 <code>ls</code> 的基础上在文件夹末尾加上 <code>/</code></li><li><strong>ls -lt</strong>: 在 <code>ls -l</code> 的基础上根据修改时间排序</li><li><strong>ls -lS</strong>: 在 <code>ls -l</code> 的基础上根据大小排序</li><li><strong>ls -l /etc</strong>: 以列表的形式列出 <code>/etc</code> 这个文件夹下的文件</li><li><strong>ls D</strong>*: 列出所有名字以 D 开头的文件夹的（<code>D*</code>是一个正则表达式）</li></ul><p>上面的输出中 <code>.</code> 表示当前路径，<code>..</code> 表示上一级路径</p><h3 id=mkdir>mkdir</h3><p>通过 mkdir 我们可以创建文件夹</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mkdir code
</span></span></code></pre></td></tr></table></div></div><p>这样我们就创建了一个 code 目录，我们可能还希望在 code 中创建一个 script 文件夹用于存放一些 shell 脚本</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mkdir code/script
</span></span></code></pre></td></tr></table></div></div><p>当然这两个文件夹我们可以一起创建，使用 -p 参数可以创建文件路径表达式中的文件夹</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mkdir -p code/script
</span></span></code></pre></td></tr></table></div></div><p>这还不够，我们可能还想一次性在 code 目录中创建 python、javascript、java文件夹，python文件夹下面有 py1、py2、py3 文件夹，javascript 文件夹 下面有 js1、js2、js3 文件夹，java文件夹下面有 java1、java2、java3 文件夹，结构如下（使用 tree 命令实现）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>code
</span></span><span class=line><span class=cl><span class=p>|</span>-- java
</span></span><span class=line><span class=cl><span class=p>|</span>   <span class=p>|</span>-- java1
</span></span><span class=line><span class=cl><span class=p>|</span>   <span class=p>|</span>-- java2
</span></span><span class=line><span class=cl><span class=p>|</span>   <span class=sb>`</span>-- java3
</span></span><span class=line><span class=cl><span class=p>|</span>-- javascript
</span></span><span class=line><span class=cl><span class=p>|</span>   <span class=p>|</span>-- js1
</span></span><span class=line><span class=cl><span class=p>|</span>   <span class=p>|</span>-- js2
</span></span><span class=line><span class=cl><span class=p>|</span>   <span class=sb>`</span>-- js3
</span></span><span class=line><span class=cl><span class=p>|</span>-- python
</span></span><span class=line><span class=cl><span class=p>|</span>   <span class=p>|</span>-- py1
</span></span><span class=line><span class=cl><span class=p>|</span>   <span class=p>|</span>-- py2
</span></span><span class=line><span class=cl><span class=p>|</span>   <span class=sb>`</span>-- py3
</span></span><span class=line><span class=cl><span class=sb>`</span>-- script
</span></span></code></pre></td></tr></table></div></div><p>对于我们想要创建多个文件夹的需求，只需要用花括号括起来就行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mkdir -p code/<span class=o>{</span>python/<span class=o>{</span>py1,py2,py3<span class=o>}</span>,javascript/<span class=o>{</span>js1,js2,js3<span class=o>}</span>,java/<span class=o>{</span>java1,java2,java3<span class=o>}}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=cd>cd</h3><p>cd: Change the current directory to DIR</p><p>有时候我们会遇到当我跳转到一个非常深的路径之后想反回的场景，如果是直接 <code>cd xxx/xxx/xxx/xxx/xx</code> 进入的，需要使用很多次 <code>cd ..</code>，当然我们也可以直接使用 <code>cd -</code> 回来（If DIR is &ldquo;-&rdquo;, it is converted to $OLDPWD.）。如果我们是使用 cd 进入了一个文件夹之后再使用 cd 进入下一个文件夹，我们可以通过一些其他方法相对快速的反回，我们可以 cd 从跟路径出发，或者从 $HOME 路径出发找到比较近的路径，当然由于在 shell 中打 $HOME 还是比较麻烦的，所以在 shell 中 <code>~</code> 会用被翻译为 $HOME，如果你想直接返回 $HOME 甚至可以直接用不带参数的 cd 命令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>cd</span> -
</span></span><span class=line><span class=cl><span class=nb>cd</span> ~
</span></span><span class=line><span class=cl><span class=nb>cd</span> /
</span></span><span class=line><span class=cl><span class=nb>cd</span> <span class=nv>$HOME</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span>
</span></span></code></pre></td></tr></table></div></div><p>然后通过 cat 重定向该文件描述符进行恢复</p><h3 id=du--sh>du -sh</h3><p>我们通过 ls 查看当前文件夹和文件列表的时候会能看到文件的大小，但是文件夹的大小只显示元数据的大小，我们可以通过 <code>du</code> 命令查看，但是 <code>du</code> 命令往往不单独使用，它会递归地列出当前目录及其所有子目录占用的磁盘空间。</p><p>在使用它之前我建议你看一下它的 flag，我们可以加上 <code>-s</code> 让它显示总大小，<code>-h</code> 可以让结果更易读</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>du -sh
</span></span></code></pre></td></tr></table></div></div><p>这样会只显示当前文件夹的总大小，可以再传入一个参数 <code>*</code> 告诉它统计当前文件夹下的所有文件夹</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>du -sh *
</span></span></code></pre></td></tr></table></div></div><h2 id=linux-权限>Linux 权限</h2><blockquote><p>在 Linux 中直接使用 root 身份执行所有操作是危险的，也许 Linux 足够安全，但是当你习惯了这个过程，对权限失去了敬畏之心的时候，危险可能就会在某个使用 Linux 的时刻出现</p></blockquote><h3 id=权限>权限</h3><p>在 Linux 中使用 id 命令可以查看当前用户的用户id，用户名和所属用户组</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>id
</span></span><span class=line><span class=cl><span class=c1># uid=1006(jichun_pu) gid=1006(jichun_pu) groups=1006(jichun_pu)</span>
</span></span></code></pre></td></tr></table></div></div><p>线上服务大部分都不涉及没有权限的文件写入操作</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ls -l /
</span></span></code></pre></td></tr></table></div></div><p>执行上面的命令之后可以看到根路径下文件夹和文件的权限，也就是第一列中的内容，代表了文件所属用户、文件所属用户的用户组和其他用户的权限</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lrwxrwxrwx.   1 root root    7 Jul 12  2018 bin -&gt; usr/bin
</span></span><span class=line><span class=cl>dr-xr-xr-x.   5 root root 4096 Jun  8  2021 boot
</span></span><span class=line><span class=cl>drwxr-xr-x    3 root root   18 Jan 18 09:57 data
</span></span><span class=line><span class=cl>drwxr-xr-x   18 root root 2940 Mar  1  2023 dev
</span></span><span class=line><span class=cl>drwxr-xr-x.  89 root root 8192 Jul 15 11:35 etc
</span></span><span class=line><span class=cl>drwxr-xr-x.  10 root root  146 Jun 20  2023 home
</span></span><span class=line><span class=cl>lrwxrwxrwx.   1 root root    7 Jul 12  2018 lib -&gt; usr/lib
</span></span><span class=line><span class=cl>lrwxrwxrwx.   1 root root    9 Jul 12  2018 lib64 -&gt; usr/lib64
</span></span><span class=line><span class=cl>drwxr-xr-x.   2 root root    6 Apr 11  2018 media
</span></span><span class=line><span class=cl>drwxr-xr-x.   2 root root    6 Apr 11  2018 mnt
</span></span><span class=line><span class=cl>drwxr-xr-x.   5 root root  107 Jan 16 14:46 opt
</span></span><span class=line><span class=cl>dr-xr-xr-x  229 root root    0 Jun  7  2022 proc
</span></span><span class=line><span class=cl>dr-xr-x---.  12 root root 4096 May 11 14:43 root
</span></span><span class=line><span class=cl>drwxr-xr-x   28 root root  960 Jun 13 11:20 run
</span></span><span class=line><span class=cl>lrwxrwxrwx.   1 root root    8 Jul 12  2018 sbin -&gt; usr/sbin
</span></span><span class=line><span class=cl>drwxr-xr-x.   2 root root    6 Apr 11  2018 srv
</span></span><span class=line><span class=cl>dr-xr-xr-x   13 root root    0 Jan 16 14:42 sys
</span></span><span class=line><span class=cl>drwxr-xr-x    3 root root   19 Nov 16  2022 titan
</span></span><span class=line><span class=cl>drwxrwxrwt.   9 root root  186 Jul 15 13:58 tmp
</span></span><span class=line><span class=cl>drwxr-xr-x.  13 root root  155 Jul 12  2018 usr
</span></span><span class=line><span class=cl>drwxr-xr-x.  20 root root  285 Nov 16  2022 var
</span></span></code></pre></td></tr></table></div></div><p>可以简单的表示为：<code>{type}{owner_role}{owner_group_role}{other_user_role}</code></p><p>常见的 type:</p><ul><li><code>l</code>: link, 表示符号链接</li><li><code>d</code>: 表示文件夹</li><li><code>-</code>: 表示普通文件</li></ul><p>后面的字符三个一组，rwx 分别表示可读、可写、可执行，如果没有对应权限就用 <code>-</code> 占位例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>drwxr-xr-x
</span></span></code></pre></td></tr></table></div></div><p>表示这是一个文件夹，当前用户有读写和执行权限，当前用户所属用户组有读和执行权限，其他用户有读和执行权限。有的时候权限这一列最后一可能还带有一个 <code>.</code> 这和Linux的安全机制有关</p><p>第二列表示文件的硬链接数量，第三列表示文件或文件夹所属用户，第四列表示文件或文件夹的元文件大小，第五到七列表示文件或文件夹最后修改日期，第八列是文件或文件夹的名称，如果最后有 <code>-> /xxx/xxx</code> 表示该文件夹或文件链接指向的文件夹或文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>lrwxrwxrwx.   1 root root    7 Jul 12  2018 bin -&gt; usr/bin
</span></span></code></pre></td></tr></table></div></div><ul><li><code>lrwxrwxrwx.</code>: 这是一个符号链接，所属用户有读写和执行权限，所属用户的所属的用户组有读写和执行权限，其他用户有读写和执行权限</li><li><code>1</code>: 这个文件夹的硬链接数量是1个</li><li><code>root</code>: 该符号链接所属用户是 root</li><li><code>root</code>: 该符号链接所属用户的用户组是 <code>root</code> (这里的用户和用户组名称是相同的)</li><li><code>7 Jul 12 2018</code>: 该符号链接最后一次修改是 2018 年7月12日</li><li><code>bin -> usr/bin</code>: 该符号链接指向的是 <code>usr/bin</code> (也就是可以理解为 /bin 文件夹其实就是 /usr/bin 文件夹)</li></ul><h3 id=修改文件权限>修改文件权限</h3><p>进入到项目文件夹中，服务器上的项目文件都是通过 rsync 同步过来的，非 root 用户是没有写权限的</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 gsspiderpy<span class=o>]</span>$ ls -lh
</span></span><span class=line><span class=cl>total 140K
</span></span><span class=line><span class=cl>drwxr-xr-x  <span class=m>5</span> root root   <span class=m>63</span> Apr <span class=m>17</span> 19:16 alert
</span></span><span class=line><span class=cl>drwxr-xr-x <span class=m>11</span> root root  <span class=m>327</span> Jul <span class=m>10</span> 15:19 core
</span></span><span class=line><span class=cl>drwxr-xr-x  <span class=m>4</span> root root   <span class=m>53</span> Apr <span class=m>17</span> 16:41 doream
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> root root  <span class=m>544</span> Jul  <span class=m>2</span> 19:42 gsspiderpy_sync.sh
</span></span><span class=line><span class=cl>drwxr-xr-x  <span class=m>9</span> root root  <span class=m>154</span> Jul <span class=m>12</span> 14:19 gsxt_search
</span></span><span class=line><span class=cl>drwxr-xr-x  <span class=m>5</span> root root   <span class=m>84</span> Jul <span class=m>10</span> 15:19 message_send
</span></span><span class=line><span class=cl>drwxr-xr-x <span class=m>11</span> root root  <span class=m>176</span> Jul  <span class=m>2</span> 14:35 notice
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> root root 117K May  <span class=m>6</span> 14:38 poetry.lock
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> root root 1.2K May  <span class=m>6</span> 14:38 pyproject.toml
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> root root 1.1K Apr <span class=m>22</span> 11:52 README.md
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> root root 1.8K Apr <span class=m>22</span> 11:52 requirements.txt
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> root root  <span class=m>572</span> Apr <span class=m>22</span> 11:52 run.py
</span></span></code></pre></td></tr></table></div></div><p>想要让非 root 用户修改 README.md 文件可以通过 chmod (change mode) 修改其他用户权限的方式完成（并不推荐这样做，并不是这样做不行，而是这个文件夹被同步之后文件权限就会恢复）</p><blockquote><p>一说到权限或者 chmod 可能就会有人想到 <code>chmod 777 filename</code> 就完事了，这和提上裤子不认人又有什么区别呢</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>sudo chmod o+w README.md
</span></span></code></pre></td></tr></table></div></div><ul><li><code>o</code>: 其他用户</li><li><code>+w</code>: 增加写权限</li></ul><p>执行完成之后不使用 sudo 提权就能修改文件成功，如果使用的是带有历史记录来撤销或恢复的这类编辑器可能会提示无法删除备份文件，但是并不影响保存成功，如果仍然觉得有困惑可以给这个文件夹为其他用户增加写权限。</p><p>同理如果想要给文件增加可执行权限，可以直接使用 <code>sudo chmod +x README.md</code></p><p>上面对文件夹或文件的操作都使用了 sudo 提权，因为这个操作的文件或文件夹的拥有者都是 root，那是否可以将文件夹或文件的拥有者改为当前用户呢？这是可以的，我们可以使用 <code>chown</code> 办到</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 coderoot<span class=o>]</span>$ sudo chown -R jichun_pu gsspiderpy
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 coderoot<span class=o>]</span>$ ls -l
</span></span><span class=line><span class=cl>total <span class=m>88</span>
</span></span><span class=line><span class=cl>drwxr-xr-x  <span class=m>8</span> root      root   <span class=m>271</span> Jun  <span class=m>4</span> 10:35 competitor_spider
</span></span><span class=line><span class=cl>drwxr-xr-x <span class=m>13</span> root      root  <span class=m>4096</span> Jul <span class=m>11</span> 16:01 gsrunner
</span></span><span class=line><span class=cl>drwxr-xr-x  <span class=m>9</span> jichun_pu root   <span class=m>291</span> Jul  <span class=m>2</span> 19:42 gsspiderpy
</span></span><span class=line><span class=cl>drwxr-xr-x <span class=m>24</span> root      root  <span class=m>4096</span> Jul <span class=m>11</span> 15:13 jsrunner
</span></span><span class=line><span class=cl>drwxr-xr-x  <span class=m>6</span> root      root    <span class=m>87</span> Nov <span class=m>22</span>  <span class=m>2022</span> venv
</span></span></code></pre></td></tr></table></div></div><p>chown (change owner) 参数意思如下:</p><ul><li><code>-R</code>: 递归更改，也就是指定目录和子目录的拥有者都将修改</li><li><code>jichun_pu</code>: 用户名</li><li><code>gsspiderpy</code>: 需要操作的文件夹</li></ul><p>再看看 gsspiderpy 中的权限</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 coderoot<span class=o>]</span>$ ls -l gsspiderpy/
</span></span><span class=line><span class=cl>total <span class=m>140</span>
</span></span><span class=line><span class=cl>drwxr-xr-x  <span class=m>5</span> jichun_pu root     <span class=m>63</span> Apr <span class=m>17</span> 19:16 alert
</span></span><span class=line><span class=cl>drwxr-xr-x <span class=m>11</span> jichun_pu root    <span class=m>327</span> Jul <span class=m>10</span> 15:19 core
</span></span><span class=line><span class=cl>drwxr-xr-x  <span class=m>4</span> jichun_pu root     <span class=m>53</span> Apr <span class=m>17</span> 16:41 doream
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> jichun_pu root    <span class=m>544</span> Jul  <span class=m>2</span> 19:42 gsspiderpy_sync.sh
</span></span><span class=line><span class=cl>drwxr-xr-x  <span class=m>9</span> jichun_pu root    <span class=m>154</span> Jul <span class=m>12</span> 14:19 gsxt_search
</span></span><span class=line><span class=cl>drwxr-xr-x  <span class=m>5</span> jichun_pu root     <span class=m>84</span> Jul <span class=m>10</span> 15:19 message_send
</span></span><span class=line><span class=cl>drwxr-xr-x <span class=m>11</span> jichun_pu root    <span class=m>176</span> Jul  <span class=m>2</span> 14:35 notice
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> jichun_pu root <span class=m>119155</span> May  <span class=m>6</span> 14:38 poetry.lock
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> jichun_pu root   <span class=m>1196</span> May  <span class=m>6</span> 14:38 pyproject.toml
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> jichun_pu root   <span class=m>1091</span> Apr <span class=m>22</span> 11:52 README.md
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> jichun_pu root   <span class=m>1836</span> Apr <span class=m>22</span> 11:52 requirements.txt
</span></span><span class=line><span class=cl>-rw-r--r--  <span class=m>1</span> jichun_pu root    <span class=m>572</span> Apr <span class=m>22</span> 11:52 run.py
</span></span></code></pre></td></tr></table></div></div><p>可以看到所有文件和文件夹的拥有者都变成了当前用户</p><h3 id=可执行权限>可执行权限</h3><p>读写和可执行三个权限其实都是非常好理解的，至于为什么要单独写一节可执行权限原因如下</p><p>在 <code>$HOME</code> 目录下创建一个 <code>listdir.sh</code> 文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># listdir.sh</span>
</span></span><span class=line><span class=cl>ls -lah
</span></span></code></pre></td></tr></table></div></div><p>这很明显是一个 shell 脚本文件，那么我们应该怎么执行呢，如果直接执行，肯定会提示没有权限，我们可能会经历下面的一系列过程</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ nvim listdir.sh
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ ./listdir.sh
</span></span><span class=line><span class=cl>-bash: ./listdir.sh: Permission denied
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ sudo ./listdir.sh
</span></span><span class=line><span class=cl>sudo: ./listdir.sh: <span class=nb>command</span> not found
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ ls -l <span class=p>|</span> grep <span class=s2>&#34;listdir&#34;</span>
</span></span><span class=line><span class=cl>-rw-rw-r-- <span class=m>1</span> jichun_pu jichun_pu         <span class=m>8</span> Jul <span class=m>15</span> 18:13 listdir.sh
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$
</span></span></code></pre></td></tr></table></div></div><p>这时候想起来没有给这个 shell 脚本赋予可执行权限，于是发现能够执行了</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ chmod +x listdir.sh
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ ./listdir.sh
</span></span><span class=line><span class=cl>total 168M
</span></span><span class=line><span class=cl>drwx------  <span class=m>12</span> jichun_pu jichun_pu 4.0K Jul <span class=m>15</span> 18:13 .
</span></span><span class=line><span class=cl>drwxr-xr-x. <span class=m>10</span> root      root       <span class=m>146</span> Jun <span class=m>20</span>  <span class=m>2023</span> ..
</span></span><span class=line><span class=cl>-rw-------   <span class=m>1</span> jichun_pu jichun_pu 183K Jul <span class=m>14</span> 15:04 .bash_history
</span></span><span class=line><span class=cl>-rw-r--r--   <span class=m>1</span> jichun_pu jichun_pu   <span class=m>18</span> Apr  <span class=m>1</span>  <span class=m>2020</span> .bash_logout
</span></span><span class=line><span class=cl>-rw-r--r--   <span class=m>1</span> jichun_pu jichun_pu  <span class=m>193</span> Apr  <span class=m>1</span>  <span class=m>2020</span> .bash_profile
</span></span><span class=line><span class=cl>-rw-r--r--   <span class=m>1</span> jichun_pu jichun_pu  <span class=m>351</span> Dec  <span class=m>9</span>  <span class=m>2022</span> .bashrc
</span></span><span class=line><span class=cl>drwxrwxr-x   <span class=m>5</span> jichun_pu jichun_pu   <span class=m>41</span> Jun <span class=m>28</span>  <span class=m>2022</span> .cache
</span></span><span class=line><span class=cl>-rw-rw-r--   <span class=m>1</span> jichun_pu jichun_pu   <span class=m>79</span> Jul  <span class=m>6</span>  <span class=m>2023</span> .clicmd
</span></span><span class=line><span class=cl>drwxrwxr-x   <span class=m>4</span> jichun_pu jichun_pu   <span class=m>33</span> Jul  <span class=m>5</span>  <span class=m>2023</span> .config
</span></span><span class=line><span class=cl>drwxrwxr-x   <span class=m>2</span> jichun_pu jichun_pu 4.0K Jul  <span class=m>9</span> 11:00 enterprise_small_update
</span></span><span class=line><span class=cl>-rw-rw-r--   <span class=m>1</span> jichun_pu jichun_pu   <span class=m>55</span> Jun  <span class=m>8</span>  <span class=m>2022</span> .gitconfig
</span></span><span class=line><span class=cl>-rw-rw-r--   <span class=m>1</span> jichun_pu jichun_pu  <span class=m>555</span> Jul  <span class=m>4</span> 18:07 imp.py
</span></span><span class=line><span class=cl>drwxrwxr-x   <span class=m>3</span> jichun_pu jichun_pu   <span class=m>29</span> Jun <span class=m>28</span>  <span class=m>2022</span> .ipython
</span></span><span class=line><span class=cl>-rw-rw-r--   <span class=m>1</span> jichun_pu jichun_pu  12K Jun  <span class=m>4</span> 15:11 .iredis_history
</span></span><span class=line><span class=cl>-rw-rw-r--   <span class=m>1</span> jichun_pu jichun_pu 2.9K Jul  <span class=m>6</span>  <span class=m>2023</span> .iredisrc
</span></span><span class=line><span class=cl>-rwxrwxr-x   <span class=m>1</span> jichun_pu jichun_pu    <span class=m>8</span> Jul <span class=m>15</span> 18:13 listdir.sh
</span></span><span class=line><span class=cl>drwx------   <span class=m>5</span> jichun_pu jichun_pu   <span class=m>41</span> Jun  <span class=m>9</span>  <span class=m>2022</span> .local
</span></span><span class=line><span class=cl>drwxrwxr-x   <span class=m>4</span> jichun_pu jichun_pu   <span class=m>72</span> Jun <span class=m>10</span>  <span class=m>2022</span> .npm
</span></span><span class=line><span class=cl>drwxrw----   <span class=m>3</span> jichun_pu jichun_pu   <span class=m>19</span> Jun  <span class=m>8</span>  <span class=m>2022</span> .pki
</span></span><span class=line><span class=cl>drwxrwxr-x   <span class=m>5</span> jichun_pu jichun_pu  <span class=m>144</span> Jun <span class=m>22</span>  <span class=m>2022</span> .pm2
</span></span><span class=line><span class=cl>-rw-------   <span class=m>1</span> jichun_pu jichun_pu  34K Jul <span class=m>14</span> 12:44 .python_history
</span></span><span class=line><span class=cl>-rw-rw-r--   <span class=m>1</span> jichun_pu jichun_pu 468K Sep <span class=m>13</span>  <span class=m>2023</span> records.csv
</span></span><span class=line><span class=cl>-rw-------   <span class=m>1</span> jichun_pu jichun_pu  <span class=m>797</span> Oct <span class=m>21</span>  <span class=m>2022</span> .rediscli_history
</span></span><span class=line><span class=cl>drwx------   <span class=m>2</span> jichun_pu jichun_pu   <span class=m>29</span> Jun  <span class=m>8</span>  <span class=m>2022</span> .ssh
</span></span></code></pre></td></tr></table></div></div><p>可能有人会疑惑，脚本里面没有 <code>Shebang</code> 行，为什么能够执行成功，其实在 Linux 中不写 <code>Shebang</code> 行，那么在执行脚本的时候会使用当前用户的 shell 去执行这个脚本，如果是个 python 脚本或者 nodejs 脚本，问题就会暴露出来</p><p><em>为什么二进制文件在赋予可执行权限的时候，不用考虑这个 <code>Shebang</code> 行，不用指定文件入口？而脚本需要？</em></p><p>上面的问题是一个陷阱，bash、python、node 这些不都是可执行文件吗，他们都是解释器，都可以交互，都可以输入文件执行，输入的文件我们通常称之为脚本，最终都是靠 bash、pytho、node 这些解释器在运行和操作系统交互。二进制可执行文件不需要解释器，它直接和操作系统交互，通过 syscall 调用完成很多事情，操作系统只要找到文件中的入口就可以了，在 Linux 中二进制文件执行步骤如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌──────────────────┐       ┌───────────────────┐       ┌─────────────────────┐
</span></span><span class=line><span class=cl>│                  │       │                   │       │                     │
</span></span><span class=line><span class=cl>│ parse elf header ├───────► read file context ├───────►exec from entry point│
</span></span><span class=line><span class=cl>│                  │       │ to memory         │       │                     │
</span></span><span class=line><span class=cl>└──────────────────┘       └───────────────────┘       └─────────────────────┘
</span></span></code></pre></td></tr></table></div></div><p>我们可以通过 <code>readelf -h main</code> 查看 entry point</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ readelf -h /usr/bin/python
</span></span><span class=line><span class=cl>ELF Header:
</span></span><span class=line><span class=cl>  Magic:   7f <span class=m>45</span> 4c <span class=m>46</span> <span class=m>02</span> <span class=m>01</span> <span class=m>01</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span> <span class=m>00</span>
</span></span><span class=line><span class=cl>  Class:                             ELF64
</span></span><span class=line><span class=cl>  Data:                              2<span class=err>&#39;</span>s complement, little endian
</span></span><span class=line><span class=cl>  Version:                           <span class=m>1</span> <span class=o>(</span>current<span class=o>)</span>
</span></span><span class=line><span class=cl>  OS/ABI:                            UNIX - System V
</span></span><span class=line><span class=cl>  ABI Version:                       <span class=m>0</span>
</span></span><span class=line><span class=cl>  Type:                              EXEC <span class=o>(</span>Executable file<span class=o>)</span>
</span></span><span class=line><span class=cl>  Machine:                           Advanced Micro Devices X86-64
</span></span><span class=line><span class=cl>  Version:                           0x1
</span></span><span class=line><span class=cl>  Entry point address:               0x400665
</span></span><span class=line><span class=cl>  Start of program headers:          <span class=m>64</span> <span class=o>(</span>bytes into file<span class=o>)</span>
</span></span><span class=line><span class=cl>  Start of section headers:          <span class=m>5288</span> <span class=o>(</span>bytes into file<span class=o>)</span>
</span></span><span class=line><span class=cl>  Flags:                             0x0
</span></span><span class=line><span class=cl>  Size of this header:               <span class=m>64</span> <span class=o>(</span>bytes<span class=o>)</span>
</span></span><span class=line><span class=cl>  Size of program headers:           <span class=m>56</span> <span class=o>(</span>bytes<span class=o>)</span>
</span></span><span class=line><span class=cl>  Number of program headers:         <span class=m>9</span>
</span></span><span class=line><span class=cl>  Size of section headers:           <span class=m>64</span> <span class=o>(</span>bytes<span class=o>)</span>
</span></span><span class=line><span class=cl>  Number of section headers:         <span class=m>29</span>
</span></span><span class=line><span class=cl>  Section header string table index: <span class=m>28</span>
</span></span></code></pre></td></tr></table></div></div><p>操作系统通过 <code>Entry point address</code> 就能找到二进制可执行文件的执行入口地址</p><h2 id=环境变量>环境变量</h2><p>谈到环境变量，可能有人会认为环境变量就是 <code>$PATH</code>，这种情况非常常见，环境、环境变量和 $PATH 傻傻分不清</p><p>他们的关系如下</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  ┌─────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>  │                                             │
</span></span><span class=line><span class=cl>  │                    environment              │
</span></span><span class=line><span class=cl>  │                                             │
</span></span><span class=line><span class=cl>  │   ┌─────────────────────────────────────┐   │
</span></span><span class=line><span class=cl>  │   │                env value            │   │
</span></span><span class=line><span class=cl>  │   │                                     │   │
</span></span><span class=line><span class=cl>  │   │         ┌────────────────┐          │   │
</span></span><span class=line><span class=cl>  │   │         │                │          │   │
</span></span><span class=line><span class=cl>  │   │         │      PATH      │          │   │
</span></span><span class=line><span class=cl>  │   │         │                │          │   │
</span></span><span class=line><span class=cl>  │   │         └────────────────┘          │   │
</span></span><span class=line><span class=cl>  │   └─────────────────────────────────────┘   │
</span></span><span class=line><span class=cl>  └─────────────────────────────────────────────┘
</span></span></code></pre></td></tr></table></div></div><p>我们可以把环境想象成正在执行的程序，环境变量是我们正在执行的程序中的一些全局变量，PATH 变量是一个比较特殊的变量</p><p>在操作系统这个环境中，我们可以随意的读取环境变量的值</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nb>echo</span> <span class=nv>$SHELL</span>
</span></span><span class=line><span class=cl>/bin/bash
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nb>echo</span> <span class=nv>$PWD</span>
</span></span><span class=line><span class=cl>/home/jichun_pu
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nb>echo</span> <span class=nv>$HOME</span>
</span></span><span class=line><span class=cl>/home/jichun_pu
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nb>echo</span> <span class=nv>$USER</span>
</span></span><span class=line><span class=cl>jichun_pu
</span></span></code></pre></td></tr></table></div></div><p>这是一些比较常见的环境变量，这些环境变量可能每个用户都不一样，他们会在用户登录的时候进行加载。</p><h3 id=环境变量加载>环境变量加载</h3><p>系统启动的时候首先会加载<strong>系统级环境变量</strong>：通过执行 <code>/etc/profile</code> 和 <code>/etc/environment</code> 完成系统级环境变量的加载</p><p>然后回加载用户级别的环境变量，用户级别的环境变量只会对当前用户生效，首先是 <code>$HOME/.profile</code>，它只会在用户第一次登录的时候执行一次，设置全局的环境变量，定义登录时需要执行的初始化命令等行为。然后应该就是我们说的 <code>$SHELL</code> 的配置文件，如果是 bash，那么加载的就是 <code>$HOME/.bashrc</code>，如果是 zsh，就是 <code>$HOME/.bashrc</code>，如果是 fish，就是 <code>$HOME/.config/fish/</code> 文件夹中的所有文件，<code>$SHELL</code> 的配置文件会在每次打开新的 <code>$SHELL</code> 的时候执行</p><p>这些文件大多数都是用 bash 写的，除了在指定条件加载外，我们还可以通过手动加载他们</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>source</span> <span class=nv>$HOME</span>/.bashrc
</span></span></code></pre></td></tr></table></div></div><p>有的安装软件的教程中会在告诉你将二进制文件除了放到 <code>/usr/bin</code> 中之外，可能也会告诉你修改 <code>/etc/profile</code> 中 <code>$PATH</code> 变量的值，从而达到在环境中找到这个可执行文件</p><blockquote><p>但是我希望告诉你的是这两种方法在大多数场景下都不是那么好，因为他们太强势了</p></blockquote><h3 id=path-变量>$PATH 变量</h3><p>前面说了半天 <code>$PATH</code> ，那么 <code>$PATH</code> 到底是什么，<code>$PATH</code> 环境变量在 Linux 和类 Unix 系统指定了 shell 在搜索可执行文件时应该查找的路径列表。具体来说，<code>$PATH</code> 定义了系统在运行命令时查找可执行文件的顺序和位置。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nb>echo</span> <span class=nv>$PATH</span>
</span></span><span class=line><span class=cl>/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin
</span></span></code></pre></td></tr></table></div></div><p>也就是说，如果我想要执行 <code>ping</code> 命令，shell 会根据 <code>$PATH</code> 中的路径列表挨个去寻找有没有 <code>ping</code> 这个拥有可执行权限的文件</p><p>事实上我们可以很轻松的在 <code>$PATH</code> 的路径列表中找到 <code>ping</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ which ping
</span></span><span class=line><span class=cl>/usr/bin/ping
</span></span></code></pre></td></tr></table></div></div><h3 id=定义变量>定义变量</h3><p>我们说 <code>$PATH</code> 路径列表，并不是说 <code>$PATH</code> 的值是一个列表，它是一个字符串，是一个包含多个路径的单个变量，每个路径由冒号分隔开来。</p><p>所以在 <code>/etc/profile</code> 或 <code>$HOME/.bashrc</code> 中修改 <code>$PATH</code> 的值的时候我们做的是字符串拼接</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>export</span> <span class=nv>PATH</span><span class=o>=</span>/usr/local/node/bin:<span class=nv>$PATH</span>
</span></span></code></pre></td></tr></table></div></div><p>在 bash 或 zsh 中，想要读取变量的值，需要在变量之前加上一个 <code>$</code>，但是我们在定义的时候并不需要使用 <code>$</code> 这个符号。</p><p>我们可以在 <code>$SHELL</code> 中定义一个变量，然后读取这个变量，然后尝试在脚本中读取这个变量看看会发生什么</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nv>TEST_VAR</span><span class=o>=</span><span class=s2>&#34;Hello&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nb>echo</span> <span class=nv>$TEST_VAR</span>
</span></span><span class=line><span class=cl>Hello
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ nvim envtest.sh
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ cat envtest.sh
</span></span><span class=line><span class=cl><span class=c1>#!/usr/bin/bash</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$TEST_VAR</span>
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ chmod +x envtest.sh
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ ./envtest.sh
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$
</span></span></code></pre></td></tr></table></div></div><p>最终我们可以看到执行 <code>envtest.sh</code> 脚本之后什么都没有输出，这说明在脚本中没有读取到这个变量。</p><p>我们在 <code>$SHELL</code> 或 脚本文件中定义的变量不一定能让别当前进程的子进程或其他进程读取到，因为他们可能没有使用 <code>export</code> 提升为环境变量，他们还只是变量，变量只能在当前进程中访问到，<code>export</code> 的作用就是让这个变量导出，而环境变量可以让当前线程的子线程也访问到</p><p>换句话说，如果我现在打开了 SSH 连接会话，我执行了 <code>export TEST_VAR=Hello</code>，那么在我没有关闭这个 SSH 会话前开启的所有程序都能读取到这个环境变量，而当我关闭这个 SSH 会话重新连接，或者直接重新连接，那么 <code>TEST_VAR</code> 这个环境变量就会失效</p><p>那么为什么写在 <code>/etc/profile</code> 或 <code>$HOME/.bashrc</code> 中的环境变量每个会话都能生效，因为每次用户登录的时候都重新加载了它们</p><p>至此说回前文，为什么不推荐直接修改 <code>/etc/profile</code> 中 <code>$PATH</code> 的值，或直接将二进制文件放入 <code>/usr/bin/</code> 目录中。</p><ul><li><code>/etc/profile</code> 中的环境变量所有用户都要加载，如果直接操作它，可能会给所有用户带来影响</li><li><code>/usr/bin</code> 每个用户的 <code>$PATH</code> 变量中都有 <code>/usr/bin</code> 这个路径，直接将二进制文件放进去也可能给别的用户带来影响。并且如果二进制文件有其他依赖也跟着放进去，后果想必也能想到是什么情况</li></ul><p>笔者更建议修改 <code>$HOME/.bashrc</code> 文件，只会对当前用户产生影响，如果是安装的类似于 python、node 这样有他们自己依赖的一些 lib 文件的二进制文件，建议使用软链接，链接到 /usr/bin 中</p><p>那么 <code>$HOME/.profile</code> 中应该写什么些什么呢？对于没有将 Linux 当作日常使用的读者可能会有此困惑，其实也很正常，大家一般使用的都是 SSH 连接服务器，服务器可以不用关机的，因此也就没有感知过第一次登录的情况，但是这其实和 Windows 下差不多，Windows下电脑重启后用户输入密码进入之后会启动一些 <code>登录项</code> 也就是自动启动的任务，<code>$HOME/.profile</code> 就是干这件事的，我们在 Linux 中可能会在第一次登录的之后让 <code>fcitx</code>、<code>compton</code> 或 <code>picom</code>、<code>bluetooch</code> 在后台启动，以及显示器缩放倍数等操作基本上都是只会在第一次登录的时候执行一次</p><h2 id=工程师运维>工程师运维</h2><h3 id=程序运行权限>程序运行权限</h3><p>在前面讲的权限中我们可以知道在正常情况下，我们想要在非用户目录下以非 root 身份运行程序似乎是比较麻烦的，大多数时候我们没有非 $HOME 下的写入权限。那是否可以将代码放到 $HOME 下运行，答案是最好不要，那什么时候可以：</p><ol><li>你确保这台服务器现在将来都只有你使用</li><li>你确保你会在公司工作到最后</li><li>如果以上两点如果无法保证，那么你能保证交接时你能处理好（PS：这种情况我自己都觉得头大）</li></ol><p>那么我们可以以 root 身份运行程序吗？答案也是最好不要，那么什么时候可以：</p><ol><li>像 docker 这种难缠的东西不得不使用的时候（其实通过用户组可以避免，但是用了用户组并不能以逸待劳）</li></ol><p>似乎我们只得使用当前用户运行，看来最好是这样的，但是有时候也不必太死板，我只是认为如果你需要在看这篇文章认为我写的有用，并且对权限这个东西无所畏惧那么最好还是注意，以免有一天你在裸机中运行的程序爆发漏洞或者用了开源库被留了暗门导致无可了一些无法挽回的损失发生。</p><p>在现代运维手段下，我们的程序如果还跑在裸机上，肯定还有一些不得已的问题，不管是历史还是个人问题，即然已经造成所以更应注意</p><p>你要知道的是，以非 root 用户权限运行，几乎不会对你的程序造成任何阉割。要在服务器上存文件，找一个磁盘空间足够的路径创建一个文件夹然后赋予读写权限就可以了，除此之外我想不到其他任何需要提权的地方。</p><p>你可能会说我的程序需要 kill 别的进程，如果是你自己的创建的进程，肯定有权限去 kill。如果是别人的进程，我们就不应该在程序中 kill，这是一件慎重的事情，应在在检查确定问题后 kill</p><h3 id=grep>grep</h3><p>在使用 grep 的时候我们应该避免使用 <code>cat filename | grep xxx</code> 这种方式筛选文件，如果文件过大会给服务器造成很大压力，grep 命令可以直接指定文件然按行读取 <code>grep xxx filename</code></p><p>grep 时写正则表达式如果觉得写很多转义符号比较麻烦，可以考虑增加 <code>-E</code> flag</p><h3 id=ps命令>ps命令</h3><p>当我们使用 ps 命令的时候只会将在前台的任务显示出来</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ ps
</span></span><span class=line><span class=cl>  PID TTY          TIME CMD
</span></span><span class=line><span class=cl><span class=m>10052</span> pts/18   00:00:00 bash
</span></span><span class=line><span class=cl><span class=m>10402</span> pts/18   00:00:00 ps
</span></span></code></pre></td></tr></table></div></div><p>我比较常用的是 <code>ps -aux</code> 这样会显示出所有的进程包括后台的进程，并且会显示足够多的信息</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/ps_command2.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/ps_command2.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/ps_command2.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/ps_command2.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/ps_command2.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/ps_command2.png></p><ul><li><p>USER: 启动这个进程的用户（进程所属用户）</p></li><li><p>PID: 进程ID（Process ID）</p></li><li><p>%CPU: 进程CPU占用率</p></li><li><p>%MEM: 进程内存占用率</p></li><li><p>VSZ: 进程占用的虚拟内存大小（Virtual Memory Size）</p></li><li><p>RSS: 进程占用物理内存大小</p></li><li><p>TTY: 启动进程的终端类型</p></li><li><p>STAT: 进程当前状态</p><ul><li>R: Running</li><li>S: Sleeping</li><li>T: Stopped</li><li>Z: Zombie （僵尸进程）</li><li>s: 表示进程是父进程，并且有子进程</li></ul><p>其他状态请自行查阅</p></li><li><p>START: 进程创建的时间</p></li><li><p>TIME: 进程在CPU上执行的时间</p></li><li><p>COMMAND: 进程启动命令</p></li></ul><h3 id=top>top</h3><p>top 是一个非常好用的命令，它非常强大，奈何我能力有限，我通常只用它来快速预览一下系统信息和查找 CPU 或 内存占用高的进程</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/top_command.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/top_command.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/top_command.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/top_command.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/top_command.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/top_command.png></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>top - 11:44:59 up 769 days, 20:19,  2 users,  load average: 0.40, 0.43, 0.39
</span></span></code></pre></td></tr></table></div></div><p>第一行表示：当前系统时间是 <code>11:47:17</code>，系统已经运行了 <code>769</code> 天 <code>20</code> 小时 <code>19</code> 分钟，当前系统登录的用户数量为 <code>2</code>，系统 1 分钟以内负载为 <code>0.40</code>，5 分钟以内负载为 <code>0.43</code>，15 分钟以内负载为 <code>0.39</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Tasks: 203 total,   1 running, 201 sleeping,   1 stopped,   0 zombie
</span></span></code></pre></td></tr></table></div></div><p>第二行表示：系统进程总数为 <code>203</code>，<code>1</code> 个正在运行中，<code>201</code> 个正在休眠中，<code>1</code> 个已经停止，<code>0</code> 个僵尸进程</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>%Cpu(s):  9.4 us,  1.6 sy,  0.0 ni, 89.1 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st
</span></span></code></pre></td></tr></table></div></div><p>第三行表示：用户态 CPU 占用百分比为 <code>9.4</code>（9.4 us），内核态 CPU 占用百分比为 <code>1.6</code>（1.6 sy），用户态改变过优先级的进程占用的 CPU 百分比为 <code>0.0</code>（0.0 ni）， 空闲的 CPU 百分比为 <code>89.1</code>（89.1 id），等待中的 CPU 百分比为 <code>0.0</code>（0.0 wa）</p><p>至于下面的进程信息和使用 ps 命令看到的基本一致。</p><p>如果没有对 top 界面进行设置，那么看到的就是这样，还是挺难看的。在 top 界面下按下 <code>?</code> 就可以进入帮助界面</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Help for Interactive Commands - procps-ng version 3.3.10
</span></span><span class=line><span class=cl>Window 1:Def: Cumulative mode Off.  System: Delay 3.0 secs; Secure mode Off.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Z,B,E,e   Global: &#39;Z&#39; colors; &#39;B&#39; bold; &#39;E&#39;/&#39;e&#39; summary/task memory scale
</span></span><span class=line><span class=cl>  l,t,m     Toggle Summary: &#39;l&#39; load avg; &#39;t&#39; task/cpu stats; &#39;m&#39; memory info
</span></span><span class=line><span class=cl>  0,1,2,3,I Toggle: &#39;0&#39; zeros; &#39;1/2/3&#39; cpus or numa node views; &#39;I&#39; Irix mode
</span></span><span class=line><span class=cl>  f,F,X     Fields: &#39;f&#39;/&#39;F&#39; add/remove/order/sort; &#39;X&#39; increase fixed-width
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  L,&amp;,&lt;,&gt; . Locate: &#39;L&#39;/&#39;&amp;&#39; find/again; Move sort column: &#39;&lt;&#39;/&#39;&gt;&#39; left/right
</span></span><span class=line><span class=cl>  R,H,V,J . Toggle: &#39;R&#39; Sort; &#39;H&#39; Threads; &#39;V&#39; Forest view; &#39;J&#39; Num justify
</span></span><span class=line><span class=cl>  c,i,S,j . Toggle: &#39;c&#39; Cmd name/line; &#39;i&#39; Idle; &#39;S&#39; Time; &#39;j&#39; Str justify
</span></span><span class=line><span class=cl>  x,y     . Toggle highlights: &#39;x&#39; sort field; &#39;y&#39; running tasks
</span></span><span class=line><span class=cl>  z,b     . Toggle: &#39;z&#39; color/mono; &#39;b&#39; bold/reverse (only if &#39;x&#39; or &#39;y&#39;)
</span></span><span class=line><span class=cl>  u,U,o,O . Filter by: &#39;u&#39;/&#39;U&#39; effective/any user; &#39;o&#39;/&#39;O&#39; other criteria
</span></span><span class=line><span class=cl>  n,#,^O  . Set: &#39;n&#39;/&#39;#&#39; max tasks displayed; Show: Ctrl+&#39;O&#39; other filter(s)
</span></span><span class=line><span class=cl>  C,...   . Toggle scroll coordinates msg for: up,down,left,right,home,end
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  k,r       Manipulate tasks: &#39;k&#39; kill; &#39;r&#39; renice
</span></span><span class=line><span class=cl>  d or s    Set update interval
</span></span><span class=line><span class=cl>  W,Y       Write configuration file &#39;W&#39;; Inspect other output &#39;Y&#39;
</span></span><span class=line><span class=cl>  q         Quit
</span></span><span class=line><span class=cl>          ( commands shown with &#39;.&#39; require a visible task display window )
</span></span><span class=line><span class=cl>Press &#39;h&#39; or &#39;?&#39; for help with Windows,
</span></span><span class=line><span class=cl>Type &#39;q&#39; or &lt;Esc&gt; to continue
</span></span></code></pre></td></tr></table></div></div><p>我一般会按 <code>e</code> 将界面信息美化一下，然后按 <code>xb</code> 增强一下显示效果</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/top3.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/top3.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/top3.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/top3.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/top3.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/top3.png></p><p>被选中的列是排序行，被选中的行就是被选中的进程，如果觉得每次进入都要设置麻烦，也可以按 <code>W</code> 将配置写入配置文件</p><p>我们想要选择排序的列，可以通过键盘上的 <code>&lt;</code> 和 <code>></code> 来进行移动</p><h3 id=定时任务>定时任务</h3><p>如果有需要定时执行的脚本，在 Linux 中可以使用 crontab，但是在设置定时任务的时候应该避免使用 <code>crontab -e</code> 这种方式会按照用户进行区分，如果服务器上有定时任务异常，那么这样会给其他排查的人员造成不必要的麻烦</p><p>我比较建议直接修改 <code>/etc/crontab</code>，在这个文件中我们同样可以指定定时任务执行的用户，并且这样也能对定时任务有比较好的区分，任何人打开这个文件就知道在这台服务器上有哪些人在上面运行什么定时任务</p><h3 id=归档日志筛选>归档日志筛选</h3><p>当线上程序或数据出现问题的时候我们通常会到日志服务器查看日志，如果日志已经归档，并且需要筛选的日志时间跨度大可以修改下面的脚本后使用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1># 解压当前文件夹下的所有tar.gz文件</span>
</span></span><span class=line><span class=cl><span class=k>for</span> file in *.tar.gz<span class=p>;</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;Extracting </span><span class=nv>$file</span><span class=s2>...&#34;</span>
</span></span><span class=line><span class=cl>    tar -xzf <span class=s2>&#34;</span><span class=nv>$file</span><span class=s2>&#34;</span> <span class=o>||</span> <span class=o>{</span> <span class=nb>echo</span> <span class=s2>&#34;Failed to extract </span><span class=nv>$file</span><span class=s2>&#34;</span><span class=p>;</span> <span class=k>continue</span><span class=p>;</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 获取解压后的文件名</span>
</span></span><span class=line><span class=cl>    <span class=nv>extracted_file</span><span class=o>=</span><span class=k>$(</span>basename <span class=s2>&#34;</span><span class=nv>$file</span><span class=s2>&#34;</span> .tar.gz<span class=k>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 使用grep进行筛选</span>
</span></span><span class=line><span class=cl>    grep -E <span class=s2>&#34;hello|world&#34;</span> <span class=s2>&#34;</span><span class=nv>$extracted_file</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 删除解压出来的文件</span>
</span></span><span class=line><span class=cl>    <span class=nb>echo</span> <span class=s2>&#34;Cleaning up...&#34;</span>
</span></span><span class=line><span class=cl>    rm <span class=s2>&#34;</span><span class=nv>$extracted_file</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=k>done</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;All done!&#34;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=进程查杀>进程查杀</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 批量查杀进程</span>
</span></span><span class=line><span class=cl><span class=k>for</span> i in <span class=sb>`</span>ps -aux <span class=p>|</span> grep <span class=s2>&#34;nvim&#34;</span> <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span><span class=sb>`</span><span class=p>;</span> <span class=k>do</span> <span class=nb>kill</span> -9 <span class=nv>$i</span><span class=p>;</span> <span class=k>done</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>对于进程查杀这是很常见的一个操作列几点需要注意的</p><ul><li>避免执行类似于 <code>echo "Kill Process xxx"</code> 之后就就没有下文的脚本</li><li>避免脚本中查询的进程匹配条件覆盖脚本名称，如果脚本名称也被匹配了，执行脚本的进程也会被杀掉</li><li>如果出现进程 kill 不了的情况，可以考虑 kill 这个进程的父进程</li><li>如果出现僵尸进程，考虑检查一下代码，通常情况下僵尸进程出现在 Python 多进程脚本中，如果僵尸进程过多，建议重启父进程</li></ul><h3 id=lsof>lsof</h3><p>lsof (list open files) 可以列出进程打开的文件、打开文件的进程、进程打开的端口（TCP/UDP）</p><p>因为在 Linxu 中任何资源都以文件的形式存在，文件不仅可以访问常规数据，还可以访问网络连接和硬件。系统在后台都为网络资源和硬件资源都分配了一个文件描述符</p><p>如果在 Linux 中我们在后台运行了一个脚本，但是脚本被我们不小心删除了，这时候我们可以通过lsof 定位到占用该文件的进程（注意：如果进行停止了，那么这个文件也就无法被恢复了），然后通过进程文件还原改文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>lsof <span class=p>|</span> grep -i delete <span class=p>|</span> grep <span class=o>{</span>filename<span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>查询到进程 ID 之后就可以在该进程文件夹中找到被删除的文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ls /proc/<span class=o>{</span>PID<span class=o>}</span>/fd
</span></span></code></pre></td></tr></table></div></div><p>查询占用端口的进程</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>lsof -i:8080
</span></span></code></pre></td></tr></table></div></div><h3 id=default-editor>default editor</h3><blockquote><p>在 Linux 我使用 nvim 编辑器</p></blockquote><p>我一般不会考虑在服务器上修改它，但是你可以作为一个了解</p><p>默认编辑器对于我而言是非常重要的一项设置，如果你知道 <code>sudoedit</code> 命令，那么应该会考虑使用 <code>sudoedit</code> 替代 <code>sudo nvim</code>，因为这是一个更安全的行为。它会创建一个零时文件，文件的内容和目标文件相同，当我们修改完文件之后会将文件覆盖过去</p><p>设置默认编辑器我们可以修改 <code>/etc/sudoers</code> 文件完成，但是系统给我们提供了一个更安全的命令 <code>visudo</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>visudo
</span></span></code></pre></td></tr></table></div></div><p>修改或增加一行就可以完成默认编辑器的设置</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Defaults  <span class=nv>editor</span><span class=o>=</span>/usr/bin/nvim
</span></span></code></pre></td></tr></table></div></div><p>如果感觉这样太暴力，或者没有权限修改这个文件，Linux 还支持环境变量 <code>$EDITOR</code>，只需要在 <code>~/.bashrc</code> 中设置即可</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>export</span> <span class=nv>EDITOR</span><span class=o>=</span>/usr/bin/nvim
</span></span></code></pre></td></tr></table></div></div><p>如果你能执行 <code>visudo</code> 那么可能会发现里面有一个用户组叫 <code>wheel</code>，这是 Linux 为我们准备的一个用户权限非常高的用户组，如果有一天你也使用 Linux 作为自己的主要系统应该会使用到它</p><h2 id=keybind-和-alias>keybind 和 alias</h2><h3 id=keybind>keybind</h3><p>shell 中通常都会有一个 <code>vi mode</code>，这个模式能帮助我们让光标在命令上快速跳转，这对于熟悉 <code>vim</code> 的人来说是好用的，我当然建议你进行尝试，但是这无疑会增加非常多的学习成本，所以我更推荐使用快捷键，这些快捷键都是通过 <code>bind</code> 命令绑定的，其中也包括 vi mode 的快捷键</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>bind</span> -p
</span></span></code></pre></td></tr></table></div></div><p>通过这个命令我们大概可以看到有哪些快捷键，因为我习惯使用 <code>vi mode</code> 所以我只知道几个快捷键，你可以通过看 <code>bind -p</code> 的输出找到你需要的快捷键，或者直接问 AI，我推荐几个我常用的快捷键</p><ul><li><code>ctrl+r</code>: 搜索历史命令</li><li><code>ctrl+l</code>: 清空屏幕</li><li><code>ctrl+u</code>: 删除光标前的内容</li><li><code>ctrl+w</code>: 删除光标前的单词</li><li><code>ctrl+x ctrl+u</code>: 撤销</li></ul><p>如果你觉得某组连串操作需要经常使用，那么你也可以通过 bind key 将快捷键和封装好的命令绑定</p><h3 id=alias>alias</h3><p>对于前面说的绑定快捷键这样的事情应该很少有人会这样做，我也仅仅因为使用 <code>joshuto</code> 绑定过快捷键，我们更多的需求往往是想将一串我经常输入的命令变得简短，比如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 激活虚拟环境</span>
</span></span><span class=line><span class=cl><span class=nb>source</span> ./.venv/bin/activate
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 进入代码文件夹</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> /opt/coderoot
</span></span></code></pre></td></tr></table></div></div><p>我们可以在 shell 中执行下面的命令然后进行尝试</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>sdv</span><span class=o>=</span><span class=s2>&#34;./.venv/bin/activate&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>alias</span> <span class=nv>cdc</span><span class=o>=</span><span class=s2>&#34;cd /opt/coderoot&#34;</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nb>alias</span> <span class=nv>cdc</span><span class=o>=</span><span class=s2>&#34;cd /opt/coderoot&#34;</span>
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nb>pwd</span>
</span></span><span class=line><span class=cl>/home/jichun_pu
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ cdc
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 coderoot<span class=o>]</span>$ <span class=nb>cd</span>
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nb>pwd</span>
</span></span><span class=line><span class=cl>/home/jichun_pu
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nb>unalias</span> cdc
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ cdc
</span></span><span class=line><span class=cl>-bash: cdc: <span class=nb>command</span> not found
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nb>echo</span> <span class=s1>&#39;alias cdc=&#34;cd /opt/coderoot&#34;&#39;</span> &gt;&gt; ~/.bashrc
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ <span class=nb>source</span> ~/.bashrc
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 ~<span class=o>]</span>$ cdc
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 coderoot<span class=o>]</span>$ <span class=nb>pwd</span>
</span></span><span class=line><span class=cl>/opt/coderoot
</span></span><span class=line><span class=cl><span class=o>[</span>jichun_pu@Qxbspideronline-10-2-6-10 coderoot<span class=o>]</span>$
</span></span></code></pre></td></tr></table></div></div><p>这是非常好用的，甚至还可以定义一个函数，用 alias 给函数起一个别名方便调用，写入完成之后执行 <code>source ~/.bashrc</code> 就会生效</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2024-07-15</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/linux/>Linux</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/rust_axum/ class=prev rel=prev title="Rust Axum框架"><i class="fas fa-angle-left fa-fw"></i>Rust Axum框架</a>
<a href=/posts/fn_fnmut_fnonce/ class=next rel=next title=Fn_FnMut_FnOnce>Fn_FnMut_FnOnce<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2019 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=http://pujichun.ink target=_blank>普吉春</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/typeit/typeit.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{},data:{"id-1":"pmnmq","id-2":"pmnmq"},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"},typeit:{cursorChar:null,cursorSpeed:null,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:null,speed:null}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>