<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Go语言是如何运行的 - pujic</title><meta name=Description content><meta property="og:title" content="Go语言是如何运行的"><meta property="og:description" content="Go 是编译型语言，不依赖虚拟机，编译成二进制的可执行程序即可运行"><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/posts/how-go-works/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-22T13:02:44+08:00"><meta property="article:modified_time" content="2022-05-22T13:02:44+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go语言是如何运行的"><meta name=twitter:description content="Go 是编译型语言，不依赖虚拟机，编译成二进制的可执行程序即可运行"><meta name=application-name content="pujic"><meta name=apple-mobile-web-app-title content="pujic"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://example.org/posts/how-go-works/><link rel=prev href=http://example.org/posts/slim-buster-image-change-apt-source/><link rel=next href=http://example.org/posts/react-fiber%E6%9E%B6%E6%9E%84/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Go语言是如何运行的","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/example.org\/posts\/how-go-works\/"},"genre":"posts","keywords":"Go","wordcount":2291,"url":"http:\/\/example.org\/posts\/how-go-works\/","datePublished":"2022-05-22T13:02:44+08:00","dateModified":"2022-05-22T13:02:44+08:00","publisher":{"@type":"Organization","name":"普吉春"},"author":{"@type":"Person","name":"普吉春"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":""==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:""==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=pujic><img class="lazyload logo" src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png><span id=id-3 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=pujic><img class="lazyload logo" src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png><span id=id-4 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Go语言是如何运行的</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=http://pujichun.ink title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>普吉春</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/go/><i class="far fa-folder fa-fw"></i>Go</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-05-22>2022-05-22</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 2291 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 5 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#可执行文件>可执行文件</a><ul><li><a href=#go-程序的编译过程>Go 程序的编译过程</a></li><li><a href=#可执行文件规范>可执行文件规范</a></li><li><a href=#系统执行可执行文件步骤>系统执行可执行文件步骤</a></li></ul></li><li><a href=#go-进程的启动与初始化>Go 进程的启动与初始化</a></li><li><a href=#go-调度器的由来>Go 调度器的由来</a><ul><li><a href=#单进程时代>单进程时代</a></li><li><a href=#提高-cpu-的利用率>提高 CPU 的利用率</a></li><li><a href=#利用协程来提高-cpu-利用率>利用协程来提高 CPU 利用率</a><ul><li><a href=#n1-关系>N:1 关系</a></li><li><a href=#11-关系>1:1 关系</a></li><li><a href=#mn-关系>M:N 关系</a></li><li><a href=#go-语言的-goroutine>Go 语言的 goroutine</a></li></ul></li></ul></li><li><a href=#调度组件与调度循环>调度组件与调度循环</a></li></ul></nav></div></div><div class=content id=content><p>Go 是编译型语言，不依赖虚拟机，编译成二进制的可执行程序即可运行</p><h2 id=可执行文件>可执行文件</h2><h3 id=go-程序的编译过程>Go 程序的编译过程</h3><div class=mermaid id=id-1></div><p>在编译目标文件时使用 <code>-x</code> 参数能够看到二进制文件生成的过程</p><p>编译阶段就是将文本代码转化为目标文件，目标文件再与标准库中已经编译好的二进制文件进行链接，链接完成之后就会在临时目录将完整的二进制文件输出，然后将编译好的程序复制到目标目录，最后再删除临时目录</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Hello World&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/go_build_flag_x.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/go_build_flag_x.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/go_build_flag_x.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/go_build_flag_x.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/go_build_flag_x.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/go_build_flag_x.png></p><h3 id=可执行文件规范>可执行文件规范</h3><p>不同的操作系统可执行文件的规范是不同的</p><table><thead><tr><th style=text-align:center>Linux</th><th style=text-align:center>Windows</th><th style=text-align:center>MacOS</th></tr></thead><tbody><tr><td style=text-align:center>ELF</td><td style=text-align:center>PE</td><td style=text-align:center>Mach-o</td></tr></tbody></table><p>Linux 的可执行文件 ELF(Executable and Linkable Format) 由以下几部分组成</p><ul><li><p>ELF header</p></li><li><p>Section header</p></li><li><p>Sections</p></li></ul><blockquote><p><a href=https://github.com/corkami/pics/blob/master/binary/elf101/elf101.pdf target=_blank rel="noopener noreffer">https://github.com/corkami/pics/blob/master/binary/elf101/elf101.pdf</a></p></blockquote><h3 id=系统执行可执行文件步骤>系统执行可执行文件步骤</h3><div class=mermaid id=id-2></div><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/readelf_go_build_binarry.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/readelf_go_build_binarry.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/readelf_go_build_binarry.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/readelf_go_build_binarry.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/readelf_go_build_binarry.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/readelf_go_build_binarry.png></p><h2 id=go-进程的启动与初始化>Go 进程的启动与初始化</h2><p>CPU 无法理解文本，只能执行一条一条的二进制机器码指令，每次执行完一条指令，pc 寄存器就会指向下一条继续执行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>go build -gcflags <span class=s2>&#34;-N -l&#34;</span> main.go
</span></span><span class=line><span class=cl>go tool objdump -s <span class=s2>&#34;main.&#34;</span> main
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/go_build_gc_dump.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/go_build_gc_dump.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/go_build_gc_dump.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/go_build_gc_dump.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/go_build_gc_dump.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/go_build_gc_dump.png></p><p>Go 语言编译出来的二进制程序由两部分组成，一部分是 Go 语言的 runtime，另一部分是用户代码</p><p>runtime 是为了实现额外的功能，而再程序运行时自动加载/运行的模块</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220522170537.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220522170537.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220522170537.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220522170537.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220522170537.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220522170537.png></p><p>Go 语言的 runtime 模块</p><table><thead><tr><th style=text-align:left>模块名称</th><th style=text-align:left>作用</th></tr></thead><tbody><tr><td style=text-align:left>Scheduler</td><td style=text-align:left>调度器管理所有的 G, M, P 在后台执行调度循环</td></tr><tr><td style=text-align:left>Netpoll</td><td style=text-align:left>强罗轮询负责管理网络 FD 相关的读写、就绪事件</td></tr><tr><td style=text-align:left>Memory</td><td style=text-align:left>当代码需要内存时，负责内存分配工作</td></tr><tr><td style=text-align:left>Garbage</td><td style=text-align:left>当内存不再需要时，负责回收内存</td></tr></tbody></table><p>这些模块中最核心的就是 Scheduler, 它负责串联是所有的 runtime 流程</p><p>通过 entry point 找到 Go进程的执行入口</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220522172336.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220522172336.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220522172336.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220522172336.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220522172336.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220522172336.png></p><p>m0 是 Go 程序启动后创建的第一个线程</p><h2 id=go-调度器的由来>Go 调度器的由来</h2><p><strong>摘自刘丹冰的博客: <a href=https://learnku.com/articles/41728#a19960 target=_blank rel="noopener noreffer">https://learnku.com/articles/41728#a19960</a></strong></p><h3 id=单进程时代>单进程时代</h3><p>单进程时代每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，一切的程序只能串行发生</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523144504.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523144504.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523144504.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523144504.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523144504.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523144504.png></p><p>早期的单进程操作系统面临两个问题：</p><ol><li><p>单一的执行流程，计算机只能一个任务一个任务处理</p></li><li><p>进程阻塞所带来的 CPU 计算时间浪费</p></li></ol><p>为了解决多个进程来宏观一起执行多个任务，操作系统具有了最早的并发能力：<code>多进程并发</code>，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把 CPU 利用起来</p><h3 id=提高-cpu-的利用率>提高 CPU 的利用率</h3><p>但是对于 Linux 操作系统来讲，cpu 对进程的态度和线程的态度是一样的。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523161520.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523161520.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523161520.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523161520.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523161520.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523161520.png></p><p>CPU 调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等</p><h3 id=利用协程来提高-cpu-利用率>利用协程来提高 CPU 利用率</h3><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存，因此又出现了新的问题</p><ul><li><p>高内存占用</p></li><li><p>调度需要消耗大量 CPU 资源</p></li></ul><p>一个线程分为<code>内核态</code>线程和<code>用户态</code>线程，一个用户态线程必须要绑定一个内核态线程，但是 CPU 并不知道有用户态线程的存在，它只知道运行的是一个内核态线程</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523162316.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523162316.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523162316.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523162316.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523162316.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523162316.png></p><p>再进行细分，内核线程依然叫<code>线程(thread)</code>，用户线程叫<code>协程(co-routine)</code></p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523162704.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523162704.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523162704.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523162704.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523162704.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523162704.png></p><p>既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程绑定一个或者多个线程上呢？</p><h4 id=n1-关系>N:1 关系</h4><p>N个协程绑定一个线程，优点就是协程再用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但是也有很大的缺点，1个进程的所有协程都绑定在1个线程上。缺点：</p><ul><li><p>某个程序用户量硬件的多核加速能力</p></li><li><p>一旦某协程阻塞，就会造成线程阻塞，本进程的其他协程都无法执行了，因此就不具备并发的能力了</p></li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523163204.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523163204.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523163204.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523163204.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523163204.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523163204.png></p><h4 id=11-关系>1:1 关系</h4><p>1个协程绑定1个线程，最容易实现，协程的调度都由 CPU 完成了，不存在 <code>N:1</code> 的缺点，但是协程的创建、删除和切换的代价都由 CPU 完成，有带你略显昂贵了</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523175436.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523175436.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523175436.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523175436.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523175436.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523175436.png></p><h4 id=mn-关系>M:N 关系</h4><p>M 个协程绑定1个线程，是 <code>N:1</code> 和 <code>1:1</code> 类型的结合，克服了以上2种模型的缺点，但是实现起来最为复杂</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523175843.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523175843.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523175843.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523175843.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523175843.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/20220523175843.png></p><p>协程和线程是有区别的，线程由 CPU 调度，是抢占式的，协程由用户态调度，是协作式的，一个协程让出 CPU 后，菜执行下一个协程</p><h4 id=go-语言的-goroutine>Go 语言的 goroutine</h4><p>Go 为了提供更容易使用的并发方法，使用了 goroutine 和 channel。goroutine 来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，改线程的其他协程也可以被 <code>runtime</code> 调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p><p>goroutine 非常的轻量，一个 goroutine 只占用几 KB 的内存，并且这几 KB 的内存就足够 goroutine 运行完，这就能在有限的内存空间中支持大量的 goroutine，支持了更多的并发。虽然一个 goroutine 的栈只占用几 KB，但实际是可伸缩的，如果需要更多内容，runtime 会自动为 goroutine 分配</p><h2 id=调度组件与调度循环>调度组件与调度循环</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Hello World in Goroutine!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>每次创建一个 Goroutine 其实是向 runtime 提交了一个计算任务，有任务产生就要有任务消费，因此 Go 的调度流程本质上是一个<code>生产-消费</code>的流程，也就是将一个任务提交到队列中，队列中的任务等待被取出执行</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/1653236319%281%29.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/1653236319%281%29.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/1653236319%281%29.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/1653236319%281%29.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/1653236319(1).png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/1653236319(1).png></p><p>Go 语言在编译时将一个任务包装为一个 <code>g</code> 也就是携程，<code>runtime/runtime2.go</code> 源代码如下(部分代码已省略)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>g</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// Stack parameters.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// stack describes the actual stack memory: [stack.lo, stack.hi).
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>stack</span>       <span class=nx>stack</span>   <span class=c1>// offset known to runtime/cgo
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>...</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span>         <span class=o>*</span><span class=nx>m</span>      <span class=c1>// current m; offset known to arm liblink
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>sched</span>     <span class=nx>gobuf</span>
</span></span><span class=line><span class=cl>	<span class=c1>// param is a generic pointer parameter field used to pass
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// values in particular contexts where other storage for the
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// parameter would be difficult to find. It is currently used
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// in three ways:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 1. When a channel operation wakes up a blocked goroutine, it sets param to
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//    point to the sudog of the completed blocking operation.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//    the GC cycle. It is unsafe to do so in any other way, because the goroutine&#39;s
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//    stack may have moved in the meantime.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//    closure in the runtime is forbidden.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>param</span>        <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl>    <span class=nx>atomicstatus</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>    <span class=nx>stackLock</span>    <span class=kt>uint32</span> <span class=c1>// sigprof/scang lock; TODO: fold in to atomicstatus
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>goid</span>         <span class=kt>int64</span>
</span></span><span class=line><span class=cl>    <span class=nx>waitsince</span>    <span class=kt>int64</span>      <span class=c1>// approx time when the g become blocked
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>lockedm</span>        <span class=nx>muintptr</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Go 最开始采用的是 <code>GM</code> 模型，但由于 <code>GM</code> 模型性能不好，在 1.1 之后进行了改进，也就有了现在的 <code>GMP</code></p><ul><li><p>G: goroutine</p></li><li><p>M: 操作系统线程</p></li><li><p>P: processor 处理器，处理 M 与 G 的关系</p></li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/1653236251%281%29.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/1653236251%281%29.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/1653236251%281%29.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/1653236251%281%29.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/1653236251(1).png title=GM模型></p><div class="details admonition question"><div class="details-summary admonition-title"><i class="icon fas fa-question-circle fa-fw"></i>Is the language called Go or Golang?<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><p>The language is called Go. The &ldquo;golang&rdquo; moniker arose because the web site was originally golang.org. (There was no .dev domain then.) Many use the golang name, though, and it is handy as a label. For instance, the Twitter tag for the language is &ldquo;#golang&rdquo;. The language&rsquo;s name is just plain Go, regardless.</p><p>A side note: Although the official logo has two capital letters, the language name is written Go, not GO.</p></div></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-05-22</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/go/>Go</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/slim-buster-image-change-apt-source/ class=prev rel=prev title="Docker slim-buster Image Change Apt Source"><i class="fas fa-angle-left fa-fw"></i>Docker slim-buster Image Change Apt Source</a>
<a href=/posts/react-fiber%E6%9E%B6%E6%9E%84/ class=next rel=next title="React Fiber架构">React Fiber架构<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2019 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=http://pujichun.ink target=_blank>普吉春</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/mermaid/mermaid.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/typeit/typeit.min.js></script><script type=text/javascript src=/lib/mermaid/mermaid.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{},data:{"id-1":`graph LR;
A[文本] --\u003e|编译| B[二进制可执行文件]`,"id-2":`graph LR;
A[解析 ELF header] --\u003e B[加载文件内容至内存] --\u003e C[从 entry point 开始执行代码]`,"id-3":"pujic","id-4":"pujic"},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"},typeit:{cursorChar:null,cursorSpeed:null,data:{"id-3":["id-3"],"id-4":["id-4"]},duration:null,speed:null}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>