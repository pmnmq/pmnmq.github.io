<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Rust 包装类型 - pujic</title><meta name=Description content><meta property="og:title" content="Rust 包装类型"><meta property="og:description" content="Rust 中有许多包装类型用于访问数据，每种都有独特性。"><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/posts/rust%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-12T20:35:08+00:00"><meta property="article:modified_time" content="2022-11-12T20:35:08+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust 包装类型"><meta name=twitter:description content="Rust 中有许多包装类型用于访问数据，每种都有独特性。"><meta name=application-name content="pujic"><meta name=apple-mobile-web-app-title content="pujic"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://example.org/posts/rust%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/><link rel=prev href=http://example.org/posts/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/><link rel=next href=http://example.org/posts/csharp%E9%9A%8F%E7%AC%94/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Rust 包装类型","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/example.org\/posts\/rust%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B\/"},"genre":"posts","keywords":"rust","wordcount":5956,"url":"http:\/\/example.org\/posts\/rust%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B\/","datePublished":"2022-11-12T20:35:08+00:00","dateModified":"2022-11-12T20:35:08+00:00","publisher":{"@type":"Organization","name":"普吉春"},"author":{"@type":"Person","name":"普吉春"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":""==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:""==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=pujic><img class="lazyload logo" src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/about/>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=pujic><img class="lazyload logo" src=/svg/loading.min.svg data-src=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png data-srcset="https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png 1.5x, https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png 2x" data-sizes=auto alt=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png title=https://pujichun-blog-1301170821.cos.ap-chengdu.myqcloud.com/img/favicon.png><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/about/ title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Rust 包装类型</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=http://pujichun.ink title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>普吉春</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/rust/><i class="far fa-folder fa-fw"></i>rust</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-11-12>2022-11-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 5956 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 12 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#基础指针类型>基础指针类型</a><ul><li><a href=#boxt>Box<t></a></li><li><a href=#copy>Copy</a></li><li><a href=#t-and-mut-t>&T and &mut T</a></li><li><a href=#const-t-and-mut-t>*const T and *mut T</a></li><li><a href=#rct>Rc<t></a><ul><li><a href=#开销>开销</a></li></ul></li></ul></li><li><a href=#cell-类型>Cell 类型</a><ul><li><a href=#cellt>Cell<t></a><ul><li><a href=#开销-1>开销</a></li></ul></li><li><a href=#refcellt>RefCell<t></a><ul><li><a href=#开销-2>开销</a></li></ul></li></ul></li><li><a href=#同步类型>同步类型</a><ul><li><a href=#arct>Arc<t></a><ul><li><a href=#开销-3>开销</a></li></ul></li><li><a href=#mutext-and-rwlockt>Mutex<t> and RwLock<t></a><ul><li><a href=#开销-4>开销</a></li></ul></li></ul></li><li><a href=#最后>最后</a></li></ul></nav></div></div><div class=content id=content><p>Rust 中有许多包装类型用于访问数据，每种都有独特性。</p><h2 id=基础指针类型>基础指针类型</h2><h3 id=boxt>Box<t></h3><p>Box<t> 是一种<code>owned</code>或<code>box</code>。虽然它可以提供对数据的借用引用，但它是数据的唯一所有者。特别是，当发生如下情况时：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// x 在这里不再可访问
</span></span></span></code></pre></td></tr></table></div></div><p>在这里，box 被移动到 y 中。由于 x 不再拥有它，编译器将不再允许开发者在此之后使用 x。一个 box 也可以通过返回值从函数中移动出来，当一个box（一个尚未移动的box）超出作用域时，deref 函数会运行，释放内部数据。</p><p>这种抽象是一种低成本的动态分配抽象。如果想在堆上分配一些内存并安全地传递一个指向该内存的指针，这是理想的选择。但是要注意，按照常规借用规则，只允许在编译时的检查的情况下共享对数据借用引用。</p><h3 id=copy>Copy</h3><p>Move/ownership 语义并不是 Box<t> 独有的；它是所有非 Copy 类型的特性。</p><p>一个 Copy 类型是其逻辑上包含的所有数据（通常是拥有的）的一个副本。这些数据通常是它的栈表示的一部分。大多数包含指向其他数据的指针的类型不是 Copy 类型，因为有额外的数据在其他地方，只复制栈表示可能会不安全地共享这些数据的所有权。</p><p>像 Vec<t> 和 String 这样也有堆上数据的类型也不是 Copy类型。像 integer/bool 这样的类型是 Copy 类型。</p><p>&T 和裸指针是 Copy。虽然它们确实指向更多的数据，但它们并不“拥有”那些数据。而 Box<t> 可以被看作是“一些恰好是动态分配的数据”，&T 被认为是“对某些数据的借用引用”。虽然两者都是指针，但只有第一个被视为“数据”。因此，第一个的复制应涉及数据的复制（这不是其栈表示的一部分），但第二个的复制只需要复制引用。&mut T 不是 Copy，因为可变引用不能共享，并且 &mut T 在某种程度上“拥有”它指向的数据，因为它可以修改这些数据。</p><p>如果一个类型的栈表示的复制不会出现内存安全，那么它可以是 Copy 类型。</p><h3 id=t-and-mut-t>&T and &mut T</h3><p><code>&T</code> 和 <code>&mut T</code> 分别是不可变引用和可变引用。它们遵循的“读写锁”模式，即对于某些数据，只能有一个可变引用，或者任意数量的不可变引用，但不能两者都有。这种保证是在编译时强制实施的，运行时没有明显的成本。在大多数情况下，这样的指针足以在代码的不同部分之间共享廉价的引用。</p><p>这些指针不能以超出其关联生命周期的方式被复制。</p><h3 id=const-t-and-mut-t>*const T and *mut T</h3><p><code>*const T</code> 和 <code>*mut T</code>是指针（类似于C语言中的原始指针），它们没有与之关联的生命周期或所有权。它们只是指向内存中的某个位置，没有其他限制。这些指针提供的唯一保证是，除非在标记为不安全的代码块中，否则不能对它们进行解引用（即不能直接访问它们指向的值）。</p><p>这些指针在构建安全且成本低的抽象（如<code>Vec&lt;T></code>）时非常有用，但在编写安全代码时应避免直接使用它们。因为直接在安全代码中使用这些原始指针很容易引发内存安全问题，如空指针解引用、悬挂指针、内存泄漏等。</p><p>在Rust等语言中，虽然提供了这种原始指针的能力，但鼓励开发者使用更安全的数据结构和操作，如智能指针（如<code>Box&lt;T></code>、<code>Rc&lt;T></code>、<code>Arc&lt;T></code>等）和所有权系统，来自动管理内存和生命周期，从而减少内存错误的风险。</p><h3 id=rct>Rc<t></h3><p><code>Rc&lt;T></code> 是 Rust 中一个具有运行时成本的智能指针包装器，它实现了引用计数机制。这意味着我们可以有多个“拥有”指向同一数据的指针，并且当所有这些指针都超出作用域时，该数据才会被释放（即deref函数会被调用）。</p><p>在内部，<code>Rc&lt;T></code> 包含一个共享的“引用计数”，每次 <code>Rc</code> 被克隆时，这个计数就会增加；每当一个 <code>Rc</code> 超出作用域时，计数就会减少。<code>Rc&lt;T></code> 的主要职责是确保对于共享的数据，在其不再被任何 <code>Rc</code> 指针引用时调用其析构函数。</p><p>值得注意的是，<code>Rc&lt;T></code> 内部的数据是不可变的。此外，如果形成了一个引用循环（即多个 <code>Rc</code> 指针相互引用，形成一个闭环），那么这些数据将无法被自动释放，从而导致内存泄漏。对于需要处理引用循环以避免内存泄漏的情况，我们需要使用垃圾收集器（Garbage Collector, GC）。</p><p>然而Rust 标准库中并没有直接提供垃圾收集器。但是，Rust 社区中有一些人在努力开发这样的工具。但是 Rust 的设计哲学通常倾向于通过所有权和生命周期规则来避免需要垃圾收集器的场景。</p><p>当希望动态分配并在程序的各个部分之间共享一些数据（只读）时，而又不确定哪个部分会是最后使用这些指针的，这时 <code>Rc&lt;T></code> 就非常有用。它是 <code>&T</code>（即裸指针或不可变引用）的一个可行替代方案，尤其是在 <code>&T</code> 的正确性无法静态检查，或者会导致编写起来极为不便的代码时。开发者可能不愿意花费太多开发成本来处理这些情况。</p><p>需要注意的是，<code>Rc&lt;T></code> 不是线程安全的，Rust 不允许它跨线程发送或共享。这有助于在不需要原子操作时避免原子操作的开销。</p><p>与 <code>Rc&lt;T></code> 相对应的还有一个姐妹类型 <code>Weak&lt;T></code>。<code>Weak&lt;T></code> 是一个非拥有（non-owning）且非借用（non-borrowed）的智能指针。它也类似于 <code>&T</code>，但在生命周期上没有限制——<code>Weak&lt;T></code> 可以永远持有。然而，由于它可能比拥有的 <code>Rc&lt;T></code> 存活时间更长，因此尝试访问内部数据时可能会失败并返回 <code>None</code>。这在需要循环数据结构或其他类似情况时非常有用。</p><p>总的来说，<code>Rc&lt;T></code> 和 <code>Weak&lt;T></code> 提供了一种在 Rust 中处理共享数据所有权和生命周期的灵活方式，尽管它们不是线程安全的，并且需要小心处理以避免内存泄漏或无效的内存访问。</p><h4 id=开销>开销</h4><p>在内存使用方面，<code>Rc&lt;T></code> 的内存分配是单一的，但它与普通的 <code>Box&lt;T></code> 相比会额外分配两个字段的空间，用于存储“强”引用计数（strong refcount）和“弱”引用计数（weak refcount）。这两个引用计数分别用于跟踪 <code>Rc&lt;T></code> 和 <code>Weak&lt;T></code> 类型的智能指针的数量。</p><p><code>Rc&lt;T></code> 在计算成本上，每次克隆（clone）时都会递增内部引用计数，每次超出作用域时都会递减引用计数。这里需要注意的是，克隆操作并不会对 <code>T</code> 类型的值进行深拷贝（deep copy），而只是简单地递增了引用计数，并返回了一个新的 <code>Rc&lt;T></code> 副本，这个副本和原始的 <code>Rc&lt;T></code> 指向同一个 <code>T</code> 类型的值。</p><p>这种设计使得 <code>Rc&lt;T></code> 在处理需要多个所有者（owner）共享同一数据的场景时非常有效，因为它避免了不必要的深拷贝，从而节省了内存和计算资源。然而，正如之前提到的，<code>Rc&lt;T></code> 不是线程安全的，并且在存在引用循环时可能会导致内存泄漏。因此，在使用时需要特别注意这些问题。</p><p>另外，<code>Weak&lt;T></code> 智能指针提供了一种解决引用循环问题的方法，因为它不拥有数据，只是提供了一种访问数据的方式，并且不会递增强引用计数。但是，由于 <code>Weak&lt;T></code> 可能在强引用计数变为零之后仍然存活，因此尝试通过 <code>Weak&lt;T></code> 访问数据时可能会失败。这种机制允许在保持数据可达性的同时，避免内存泄漏。</p><h2 id=cell-类型>Cell 类型</h2><p>“Cells” 提供了内部可变性。换句话说，它们包含的数据即使在其类型无法以可变形式获取的情况下（例如，当数据位于 &-ptr 或 Rc<t> 后面时）也可以被操作。</p><p>关于这些的说明，<code>cell</code> 模块的文档中有很好的解释。</p><p>这些类型通常出现在结构体字段中，但也可能在其他地方找到。</p><h3 id=cellt>Cell<t></h3><p><code>Cell&lt;T></code> 是一种提供零成本内部可变性的类型，但它仅适用于 <code>Copy</code> 类型的值。由于编译器知道被包含的值所拥有的所有数据都在栈上，因此简单地替换数据不会导致任何数据通过引用泄露（或更糟的情况）。</p><p>然而，使用此包装器时仍有可能违反您自己的不变性规则。如果一个字段被 <code>Cell</code> 包装，那么表明该数据块是可变的，并且可能在首次读取它和打算使用它之间发生变化。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Cell</span>::<span class=n>new</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>x</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>y</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>z</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=n>get</span><span class=p>());</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>在这里我们能够通过各种不可变引用来修改相同的值。</p><p>这与以下的运行时成本相同：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>z</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>*</span><span class=n>y</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>3</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>*</span><span class=n>z</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>4</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>但是，它有一个额外的好处，那就是实际上能够编译成功。</p><h4 id=开销-1>开销</h4><p>使用 <code>Cell&lt;T></code> 在运行时是没有成本的，但是如果用它来包装较大的（<code>Copy</code>）结构体，那么可能值得考虑将结构体的各个字段分别包装在 <code>Cell&lt;T></code> 中，因为每次写入都会对整个结构体进行完整的复制。</p><h3 id=refcellt>RefCell<t></h3><p><code>RefCell&lt;T></code> 同样提供了内部可变性，但它并不局限于 <code>Copy</code> 类型的值。</p><p>相反，<code>RefCell&lt;T></code> 有一个运行时成本。<code>RefCell&lt;T></code> 在运行时强制实现了类似读写锁（RWLock）的模式（尽管它更像是一个单线程的互斥锁），这与 <code>&T</code> 和 <code>&mut T</code> 在编译时进行的借用检查不同。这是通过 <code>borrow()</code> 和 <code>borrow_mut()</code> 函数来实现的，这两个函数会修改内部的一个引用计数，并返回智能指针，这些智能指针可以分别被不可变和可变地解引用。当这些智能指针超出作用域时，引用计数会被恢复。通过这个系统，我们可以动态地确保在有一个可变借用处于活动状态时，不会有其他任何借用（无论是可变还是不可变）处于活动状态。如果程序员试图进行这样的借用，程序将会发生 panic。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>let x = RefCell::new(vec![1,2,3,4]);
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    println!(&#34;{:?}&#34;, *x.borrow())
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    let my_ref = x.borrow_mut();
</span></span><span class=line><span class=cl>    my_ref.push(1);
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>类似于 <code>Cell</code>，<code>RefCell</code> 主要用于那些难以满足借用检查器（borrow checker）要求的情况。通常，我们知道这样的突变不会以嵌套的形式发生，但进行检查总是好的。</p><p>对于大型、复杂的程序，将某些内容放入 <code>RefCell</code> 以简化事情变得很有用。例如，Rust 编译器内部 <code>ctxt</code> 结构体中的许多映射都位于这个包装器内部。这些映射通常只被修改一次（在创建期间，而不是在初始化之后立即）或在几个分离的地方被修改几次。然而，由于这个结构体被广泛使用，因此处理可变和不可变指针将会非常困难（甚至可能不可能），并且可能会形成一团难以扩展的 <code>&</code> 指针的混乱。另一方面，<code>RefCell</code> 提供了一种廉价（尽管不是零成本）的方式来安全地访问这些映射。在未来，如果有人添加了尝试在已借用时修改单元的代码，它将导致一个（通常是确定的）panic，这个panic可以追踪到导致问题的借用。</p><p>类似地，在 Servo 的 DOM 中，我们有很多突变，其中大多数突变是局部的，属于某个 DOM 类型，但也有一些突变会跨越 DOM 并修改各种事物。使用 <code>RefCell</code> 和 <code>Cell</code> 来保护所有突变可以让我们不必到处担心可变性，并且同时突出显示实际发生突变的位置。</p><p>请注意，如果可以使用 <code>&</code> 指针以更简单的方式解决问题，则应避免使用 <code>RefCell</code>。</p><h4 id=开销-2>开销</h4><p><code>RefCell</code> 本身并不进行内存分配，但它除了存储数据之外，还包含一个额外的“借用状态”指示器（通常是一个字的大小）。在运行时，每次进行借用操作时，都会对这个引用计数进行修改或检查。</p><h2 id=同步类型>同步类型</h2><p>上面提到的许多类型都不能以线程安全的方式使用。特别是 <code>Rc&lt;T></code> 和 <code>RefCell&lt;T></code>，它们都使用非原子的引用计数，因此不能这样使用。这使得它们使用起来更便宜，但人们也需要这些类型的线程安全版本。这些版本是存在的，它们分别是 <code>Arc&lt;T></code> 和 <code>Mutex&lt;T></code>/<code>RWLock&lt;T></code>。</p><p>请注意，非线程安全的类型不能在线程之间发送，这一点在编译时会被检查。</p><h3 id=arct>Arc<t></h3><p><code>Arc&lt;T></code> 是 <code>Rc&lt;T></code> 的一个版本，它使用原子引用计数。<code>Arc&lt;T></code> 可以在线程之间自由发送。</p><p>C++ 的 <code>shared_ptr</code> 与 <code>Arc</code> 类似，但在 C++ 的情况下，内部数据总是可变的。为了获得与 C++ 类似的语义，我们应该使用 <code>Arc&lt;Mutex&lt;T>></code>、<code>Arc&lt;RwLock&lt;T>></code> 或 <code>Arc&lt;UnsafeCell&lt;T>></code>（<code>UnsafeCell&lt;T></code> 是一种可以存储任何数据的单元类型，没有运行时成本，但访问它需要 unsafe 代码块）。最后一个选项（<code>Arc&lt;UnsafeCell&lt;T>></code>）仅当确定使用它不会导致任何内存不安全时才应使用。请记住，写入结构体不是一个原子操作，而且许多函数（如 <code>vec.push()</code>）可能会在内部重新分配并导致不安全行为。</p><h4 id=开销-3>开销</h4><p>这增加了使用原子操作来改变引用计数的成本（每当它被克隆或超出作用域时都会发生）。当在单个线程中共享来自 <code>Arc</code> 的数据时，尽可能共享 <code>&</code> 指针是更好的选择。</p><h3 id=mutext-and-rwlockt>Mutex<t> and RwLock<t></h3><p><code>Mutex&lt;T></code> 和 <code>RwLock&lt;T></code> 通过 RAII（Resource Acquisition Is Initialization）保护提供互斥。</p><p>互斥锁在调用其 <code>lock()</code> 方法之前是不透明的，此时线程将阻塞，直到可以获得锁，然后返回一个保护对象。这个保护对象可以用来访问内部数据（可变的），并且当保护对象超出作用域时，锁将被释放。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>guard</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mutex</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>*</span><span class=n>guard</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w> </span><span class=c1>// 释放锁
</span></span></span></code></pre></td></tr></table></div></div><p><code>RwLock</code> 的额外好处在于它对多个读取操作是高效的。只要没有写入者，就可以安全地允许多个读取者访问共享数据；而 <code>RwLock</code> 允许读取者获得“读锁”。这样的锁可以并发地获得，并通过引用计数来跟踪。写入者必须获得“写锁”，而写锁只有在所有读取者都超出作用域后才能获得。</p><h4 id=开销-4>开销</h4><p>这些锁使用类似于内部原子类型的机制来维护锁，而这些锁是相当昂贵的（它们可以阻塞跨处理器的所有内存读取，直到它们完成）。当有很多并发访问发生时，等待这些锁也可能很慢。</p><h2 id=最后>最后</h2><p>阅读 Rust 代码时，经常会看到 <code>Rc&lt;RefCell&lt;Vec&lt;T>>></code> 这样的类型以及这些类型的更复杂组合。</p><p>通常，这是在将所需的 guard 组合在一起，同时避免为不必要的东西付出代价。</p><p>例如，<code>Rc&lt;RefCell&lt;T>></code> 就是这样一个组合。<code>Rc</code> 本身不能可变地解引用；因为 <code>Rc</code> 提供共享，而共享的可变性是不好的，所以我们把 <code>RefCell</code> 放在里面以获得动态验证的共享可变性。现在我们有了共享的可变数据，但它是以一种方式共享的，即一次只能有一个修改者（且没有读者）或多个读者。</p><p>现在，我们可以更进一步，使用 <code>Rc&lt;RefCell&lt;Vec&lt;T>>></code> 或 <code>Rc&lt;Vec&lt;RefCell&lt;T>>></code>。这两者都是可共享、可变的向量，但它们并不相同。</p><p>对于前者，<code>RefCell</code> 包裹了整个 <code>Vec</code>，因此整个 <code>Vec</code> 都是可变的。同时，在给定时间内，整个 <code>Vec</code> 只能有一个可变借用。这意味着你的代码不能同时从不同的 <code>Rc</code> 句柄上操作向量的不同元素。但是，我们可以随意地向 <code>Vec</code> 中添加和删除元素。这类似于一个 <code>&mut Vec&lt;T></code>，但借用检查是在运行时进行的。</p><p>对于后者，是对单个元素的借用，但整个向量是不可变的。因此，我们可以独立地借用不同的元素，但我们不能向向量中添加或删除元素。这类似于一个 <code>&mut [T]</code>，但同样，借用检查是在运行时进行的。</p><p>在并发程序中，我们有一个类似的情况，即 <code>Arc&lt;Mutex&lt;T>></code>，它提供了共享的可变性和所有权。</p><p>当阅读使用这些类型的代码时，要逐步进行，并查看所提供的保证/成本。</p><p>在选择组合类型时，我们必须反过来做；确定我们想要的保证，以及在组合的哪个点需要它们。例如，如果在 <code>Vec&lt;RefCell&lt;T>></code> 和 <code>RefCell&lt;Vec&lt;T>></code> 之间进行选择，我们应该像上面那样权衡利弊，然后选择一个。</p><p>如果还是不太确定自己在开发中应该怎么选择它们可以参考下面这幅社区中的大佬给出的图</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>+-----------+
</span></span><span class=line><span class=cl>| Ownership |
</span></span><span class=line><span class=cl>+--+--------+                              +================+
</span></span><span class=line><span class=cl>   |                         +-Static-----&gt;| T              |(1)
</span></span><span class=line><span class=cl>   |                         |             +================+
</span></span><span class=line><span class=cl>   |                         |
</span></span><span class=line><span class=cl>   |                         |             +================+
</span></span><span class=line><span class=cl>   |          +-----------+  | Local    Val| Cell&lt;T&gt;        |(1)
</span></span><span class=line><span class=cl>   +-Unique--&gt;| Borrowing +--+-Dynamic----&gt;|----------------|
</span></span><span class=line><span class=cl>   |          +-----------+  |          Ref| RefCell&lt;T&gt;     |(1)
</span></span><span class=line><span class=cl>   |                         |             +================+
</span></span><span class=line><span class=cl>   |                         |
</span></span><span class=line><span class=cl>   |                         |             +================+
</span></span><span class=line><span class=cl>   |                         | Threaded    | AtomicT        |(2)
</span></span><span class=line><span class=cl>   |                         +-Dynamic----&gt;|----------------|
</span></span><span class=line><span class=cl>   |                                       | Mutex&lt;T&gt;       |(1)
</span></span><span class=line><span class=cl>   |                                       | RwLock&lt;T&gt;      |(1)
</span></span><span class=line><span class=cl>   |                                       +================+
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   |                                       +================+
</span></span><span class=line><span class=cl>   |                         +-No---------&gt;| Rc&lt;T&gt;          |
</span></span><span class=line><span class=cl>   |                         |             +================+
</span></span><span class=line><span class=cl>   | Locally  +-----------+  |
</span></span><span class=line><span class=cl>   +-Shared--&gt;| Mutable?  +--+             +================+
</span></span><span class=line><span class=cl>   |          +-----------+  |          Val| Rc&lt;Cell&lt;T&gt;&gt;    |
</span></span><span class=line><span class=cl>   |                         +-Yes--------&gt;|----------------|
</span></span><span class=line><span class=cl>   |                                    Ref| Rc&lt;RefCell&lt;T&gt;&gt; |
</span></span><span class=line><span class=cl>   |                                       +================+
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   |                                       +================+
</span></span><span class=line><span class=cl>   |                         +-No---------&gt;| Arc&lt;T&gt;         |
</span></span><span class=line><span class=cl>   |                         |             +================+
</span></span><span class=line><span class=cl>   | Shared   +-----------+  |
</span></span><span class=line><span class=cl>   +-Between-&gt;| Mutable?  +--+             +================+
</span></span><span class=line><span class=cl>     Threads  +-----------+  |             | Arc&lt;AtomicT&gt;   |(2)
</span></span><span class=line><span class=cl>                             +-Yes--------&gt;|----------------|
</span></span><span class=line><span class=cl>                                           | Arc&lt;Mutex&lt;T&gt;&gt;  |
</span></span><span class=line><span class=cl>                                           | Arc&lt;RwLock&lt;T&gt;&gt; |
</span></span><span class=line><span class=cl>                                           +================+
</span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-11-12</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/rust/>rust</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/ class=prev rel=prev title=开源工具><i class="fas fa-angle-left fa-fw"></i>开源工具</a>
<a href=/posts/csharp%E9%9A%8F%E7%AC%94/ class=next rel=next title=C#随笔>C#随笔<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2019 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=http://pujichun.ink target=_blank>普吉春</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/typeit/typeit.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{},data:{"id-1":"pujic","id-2":"pujic"},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"},typeit:{cursorChar:null,cursorSpeed:null,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:null,speed:null}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>