<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Python - 标签 - pmnmq</title><link>http://example.org/tags/python/</link><description>Python - 标签 - pmnmq</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>pujichun@outlook.com (普吉春)</managingEditor><webMaster>pujichun@outlook.com (普吉春)</webMaster><lastBuildDate>Sat, 23 Sep 2023 22:05:27 +0800</lastBuildDate><atom:link href="http://example.org/tags/python/" rel="self" type="application/rss+xml"/><item><title>用 Rust 开发一个 python 模块</title><link>http://example.org/posts/rust_%E5%BC%80%E5%8F%91python%E6%A8%A1%E5%9D%97/</link><pubDate>Sat, 23 Sep 2023 22:05:27 +0800</pubDate><author>作者</author><guid>http://example.org/posts/rust_%E5%BC%80%E5%8F%91python%E6%A8%A1%E5%9D%97/</guid><description>&lt;p>python urllib3 内存泄漏问题偶尔会蹦出来烦我一下，于是萌生了能不能用 Rust 写一个请求库&lt;/p></description></item><item><title>poetry - python 的包管理工具</title><link>http://example.org/posts/poetry2/</link><pubDate>Sat, 20 May 2023 10:30:04 +0000</pubDate><author>作者</author><guid>http://example.org/posts/poetry2/</guid><description>以下功能中不管是静态检查插件、格式化工具配置、launch profile 等，基本都可以使用 pycharm 和 vscode 做到，但是都同时做到是不可能的，像 black 在 pycharm 中配置起来还是比</description></item><item><title>python日志库loguru</title><link>http://example.org/posts/python%E6%97%A5%E5%BF%97%E5%BA%93loguru/</link><pubDate>Sun, 08 Aug 2021 17:41:41 +0000</pubDate><author>作者</author><guid>http://example.org/posts/python%E6%97%A5%E5%BF%97%E5%BA%93loguru/</guid><description><![CDATA[<p>日志在开发中还是很常用的，虽然我们可以使用最原始的<code>system.out</code>但是这样做太简陋了，我在开发的过程中很多时候都会使用日志，在处理异常的时候或者执行某个关键方法的时候我都会使用日志，因为这样能更好的监控程序，但是使用python中的<code>logging</code>库还是比较麻烦的，虽然每次都是复制粘贴以前写的配置，但是改起来的时候还是挺麻烦的</p>]]></description></item><item><title>python 异步下载壁纸</title><link>http://example.org/posts/python-%E5%BC%82%E6%AD%A5%E4%B8%8B%E8%BD%BD%E5%A3%81%E7%BA%B8/</link><pubDate>Wed, 19 May 2021 19:08:05 +0000</pubDate><author>作者</author><guid>http://example.org/posts/python-%E5%BC%82%E6%AD%A5%E4%B8%8B%E8%BD%BD%E5%A3%81%E7%BA%B8/</guid><description>&lt;p>实不相瞒，作为一个喜欢收集壁纸的boy，我盯上&lt;a href="https://wallhaven.cc/" target="_blank" rel="noopener noreffer">wallhaven&lt;/a>很久了&lt;/p></description></item><item><title>加速下班之collections模块</title><link>http://example.org/posts/%E5%8A%A0%E9%80%9F%E4%B8%8B%E7%8F%AD%E4%B9%8Bcollections%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/</link><pubDate>Mon, 26 Apr 2021 15:11:22 +0000</pubDate><author>作者</author><guid>http://example.org/posts/%E5%8A%A0%E9%80%9F%E4%B8%8B%E7%8F%AD%E4%B9%8Bcollections%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97/</guid><description>&lt;p>collections模块实现了特定目标的容器，这些容器能够帮助开发者快速简洁的实现想法&lt;/p></description></item><item><title>Python上下文管理器</title><link>http://example.org/posts/python%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</link><pubDate>Sat, 24 Apr 2021 21:56:09 +0000</pubDate><author>作者</author><guid>http://example.org/posts/python%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</guid><description>&lt;p>如果经常使用Python应该能注意到Python中经常出现&lt;code>with&lt;/code>关键字。&lt;/p></description></item><item><title>单例模式</title><link>http://example.org/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Wed, 21 Apr 2021 12:20:45 +0000</pubDate><author>作者</author><guid>http://example.org/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>&lt;p>单例模式，属于创建类型的一种常用的软件设计模式。通过单例模式的方法创建的类在当前进程中只有一个实例&lt;/p></description></item><item><title>pandas数据处理小技巧1</title><link>http://example.org/posts/pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B8%80/</link><pubDate>Sat, 17 Apr 2021 16:57:29 +0000</pubDate><author>作者</author><guid>http://example.org/posts/pandas%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B8%80/</guid><description>&lt;p>pandas数据处理小技巧1——增长率&lt;/p></description></item><item><title>Kafka安装与使用</title><link>http://example.org/posts/kafka%E4%BD%BF%E7%94%A8/</link><pubDate>Fri, 09 Apr 2021 13:54:56 +0000</pubDate><author>作者</author><guid>http://example.org/posts/kafka%E4%BD%BF%E7%94%A8/</guid><description>&lt;p>Kafka是一个高吞吐率的分布式订阅消息队列，传统的关系存储型数据库，如MySQL、MongoDB都有一个痛点，那就是性能较差，在高并发访问的情况下很可能会奔溃掉。其实redis中有一个用于消息订阅的数据结构&lt;code>queue&lt;/code>，但是redis中的数据是放到内存当中的，如果消息量过大很可能会造成内存奔溃，而且如果机器发生故障，内存中的数据很可能会清空。&lt;/p></description></item><item><title>Python MySQL连接池</title><link>http://example.org/posts/python-mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link><pubDate>Thu, 08 Apr 2021 14:36:46 +0000</pubDate><author>作者</author><guid>http://example.org/posts/python-mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid><description>&lt;p>在并发的场景下，不可避免的就是MySQL的访问问题，由于MySQL的性能并不强，因此在进行并发访问的时候往往会使用连接池。&lt;/p></description></item></channel></rss>